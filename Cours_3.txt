                                   Transmettez des données de page en page

Écoutez la requête de vos utilisateurs grâce aux URL

Grâce aux URL et à PHP, nous allons rendre le formulaire de contact dynamique en retournant une page de prise en compte de la demande à chaque personne qui soumettra le formulaire.

Je crois savoir ce qu'est une URL ; mais j'ai besoin d'en savoir plus pour lire ce chapitre ?

Un petit peu.

URL signifie Uniform Resource Locator. C'est en fait une adresse sur le Web.

Toutes les adresses que vous voyez en haut de votre navigateur, comme : https://www.openclassrooms.com sont des URL.

Lorsque vous faites une recherche sur Google pour trouver le site d'OpenClassrooms en tapant le mot "OpenClassrooms", la barre d'adresse contient une URL un peu longue qui ressemble à ceci :

http://www.google.fr/search?rlz=1C1GFR343&q=openclassrooms

Pourquoi ? Qu'est-ce que ça veut dire ?

Les informations après le point d'interrogation ? sont en réalité des données que l'on fait transiter d'une page à une autre. Nous allons découvrir dans ce chapitre comment cela fonctionne.

Envoyez des paramètres dans l'URL

Les URL permettent de transmettre des informations. Comment est-ce que ça fonctionne, exactement ? J'y viens !

Formez une URL pour envoyer des paramètres
Imaginons :

  - votre site s'appelle  monsite.com  ;

  - et possède une page PHP de contact :    contact.php  .

Pour accéder à la page de contact, vous devez aller à l'URL suivante :

http://www.monsite.com/contact.php

Jusque-là, rien de bien nouveau. Ce que je vous propose d'apprendre à faire, c'est d'envoyer des informations à la page  contact.php  .

Ces informations vont figurer à la fin de l'URL, comme ceci :

http://www.monsite.com/contact.php?nom=Dupont&prenom=Jean

Ce que vous voyez après le point d'interrogation, ce sont des paramètres que l'on envoie à la page PHP. Celle-ci peut récupérer ces informations dans des variables.

Voici comment on peut découper cette URL :

Le point d'interrogation sépare le nom de la page PHP des paramètres.

Les paramètres s'enchaînent selon la forme nom=valeur et sont séparés les uns des autres par le symbole   &  .

On peut écrire autant de paramètres que l'on veut ?

En théorie, oui.

Il suffit de les séparer par des & comme je l'ai fait. On peut donc voir une URL de la forme : 

page.php?param1=valeur1&param2=valeur2&param3=valeur3&param4=valeur4…

La seule limite est la longueur de l'URL. En général, il n'est pas conseillé de dépasser les 256 caractères, mais les navigateurs arrivent parfois à gérer des URL plus longues.

Créez un lien avec des paramètres

Maintenant que nous savons cela, nous pouvons créer des liens en HTML, qui transmettent des paramètres d'une page vers une autre.

Imaginons que vous ayez deux fichiers sur votre site :

  - index.php  (l'accueil) ;

  - bonjour.php .

Nous voulons faire un lien de index.php  à bonjour.php  pour transmettre des informations dans l'URL :

Pour cela, ouvrez index.php  (puisque c'est lui qui contiendra le lien) et insérez-y par exemple le code suivant :

<a href="bonjour.php?nom=Dupont&amp;prenom=Jean">Dis-moi bonjour !</a>
Comme vous le voyez, le &  dans le code a été remplacé par &amp;  dans le lien.

Ça n'a rien à voir avec PHP : simplement, en HTML, on demande à ce que les &  soient écrits &amp;  dans le code source.

Si vous ne le faites pas, le code ne passera pas la validation W3C.

Ce lien appelle la page bonjour.php et lui envoie deux paramètres :

  - nom : Dupont ;

  - prenom : Jean.

Créez un formulaire avec la méthode HTTP GET

Ce chapitre suppose que vous êtes capable de créer des formulaires à l'aide du langage HTML. Si vous ne vous sentez pas prêt, pas de panique : il suffit de lire le chapitre sur les formulaires du cours HTML & CSS. 

La deuxième solution pour faire passer des informations dans l'URL, c'est de proposer à l'utilisateur de soumettre un formulaire avec la méthode HTTP GET.

Nous pouvons faire cela avec une balise form qui a pour attribut method la valeur GET.

<form action="contact.php" method="GET">
    <!-- données à faire passer à l'aide d'inputs -->
    <input name="nom">
    <input name="prenom">
</form>

Les données soumises à l'aide du formulaire se retrouveront dans l'URL, comme pour un lien.

Comment faire dans la page contact.php ou dans bonjour.php pour récupérer ces informations ?

C'est ce que nous allons voir maintenant !

Récupérez les paramètres en PHP

Nous savons maintenant comment faire pour envoyer des paramètres vers une autre page.

Intéressons-nous maintenant à la page qui réceptionne les paramètres.

Pour notre besoin, nous avons un formulaire de contact – contact.php  – que nous allons soumettre sur une autre page, et qui affichera un message de bonne réception :submit_contact.php

Pour rappel, voici le formulaire de contact (simplifié) que nous avions dans le chapitre précédent :

<form action="submit_contact.php" method="GET">
    <div>
        <label for="email">Email</label>
        <input type="email" name="email">
    </div>
    <div>
        <label for="message">Votre message</label>
        <textarea placeholder="Exprimez vous" name="message"></textarea>
    </div>
    <button type="submit">Envoyer</button>
</form>

Par exemple, si l'utilisateur complète le formulaire de contact avec pour e-mail utilisateur@exemple.com et comme message "Bonjour".

Le formulaire va alors être converti en lien vers :submit_contact.php?email=utilisateur%40exemple.com&message=Bonjour 

Et ces informations pourront être récupérées par PHP dans le fichier submit_contact.php .

Lors de la soumission, une variable superglobale appelée $_GET  va contenir les données envoyées. Il s'agit d'un tableau associatif dont les clés correspondent aux noms des paramètres envoyés dans l'URL :

Nom                Valeur

$_GET['email']     utilisateur@exemple.com

$_GET['message']   Bonjour


On peut donc :

  - récupérer ces informations ;

  - les traiter ;

  - les afficher ;

  - bref, faire ce que l'on veut avec.

Pour l'exemple, créez un nouveau fichier PHP submit_contact.php et placez-y le code suivant :

<h1>Message bien reçu !</h1>
        
<div class="card">
    
    <div class="card-body">
        <h5 class="card-title">Rappel de vos informations</h5>
        <p class="card-text"><b>Email</b> : <?php echo $_GET['email']; ?></p>
        <p class="card-text"><b>Message</b> : <?php echo $_GET['message']; ?></p>
    </div>
</div>

Vous obtiendrez le résultat suivant :

Ne faites jamais confiance aux données reçues !

Il ne faut JAMAIS faire confiance aux variables qui transitent de page en page, comme $_GET  que nous étudions ici.

Oui je suis alarmiste, et oui je veux que vous ayez – un peu – peur !

Mais rassurez-vous : je vais vous expliquer tout ce qu'il faut savoir pour que ça se passe bien et que vous ne risquiez rien.

Tous les visiteurs peuvent trafiquer les URL
Si vous faites les tests des codes précédents chez vous, vous devriez tomber sur une URL de la forme :

http://localhost/submit_contact.php?email=utilisateur%40exemple.com&message=Bonjour

Mais si vous êtes un peu bricoleur, vous pouvez vous amuser à changer les paramètres directement dans la barre d'adresse, comme ici :

Essayez par exemple de modifier l'adresse pour :

http://localhost/submit_contact.php?email=utilisateur%40exemple.com&message=Mouahah

Comme vous le voyez, ça marche ! N'importe qui peut facilement modifier les URL et y mettre ce qu'il veut : il suffit simplement de changer l'URL dans la barre d'adresse de votre navigateur.

Et alors, quel est le problème ? C'est pas plus mal, si le visiteur veut adapter l'URL pour modifier le message ou l'e-mail qu'il nous a envoyé ?

Peut-être, mais cela montre une chose : on ne peut pas avoir confiance dans les données qu'on reçoit. N'importe quel visiteur peut les changer. 

Testez la présence d'un paramètre

Allons plus loin. Qu'est-ce qui empêche le visiteur de supprimer tous les paramètres de l'URL ? Par exemple, il peut très bien tenter d'accéder à :

http://localhost/submit_contact.php

Que va afficher la page submit_contact.php  ?

Faites le test ! Elle va afficher quelque chose comme :

Notice: Undefined index: email in submit_contact.php on line 15

OU

Warning: Undefined array key "email" in submit_contact.php on line 15

Que s'est-il passé ?

On a essayé d'afficher la valeur de $_GET['email']  et celle de  $_GET['message']  .

Mais comme on vient de les supprimer de l'URL, ces variables n'ont pas été créées, et donc elles n'existent pas ! PHP nous avertit qu'on essaie d'utiliser des variables qui n'existent pas, d'où les « Undefined index ».

Pour résoudre ce problème, on peut faire appel à une fonction un peu spéciale :  isset()  .

La fonction isset() teste si une variable existe.

Nous allons nous en servir pour afficher un message spécifique, dans le cas où le nom ou le prénom serait absent.

<?php
$getData = $_GET;

if (!isset($getData['email']) || !isset($getData['message']))
{
    echo('Il faut un email et un message pour soumettre le formulaire.');
    // Arrête l'exécution de ce fichier par PHP
    return;
}
?>
Que fait ce code ?

Il teste si les variables $getData['email']  et $getData['message']  existent.

  1. Si elles existent, on affiche la confirmation de prise en compte du message.

  2. S'il nous manque une des variables (ou les deux), on affiche un message d'erreur : "Il faut un e-mail et 
     un message pour soumettre le formulaire", et on arrête l'exécution de la page.

Essayez maintenant d'accéder à la page submit_contact.php sans les paramètres.

Vous allez voir qu'on gère bien le cas où le visiteur aurait retiré les paramètres de l'URL :

Est-ce que c'est vraiment la peine de gérer ce cas ? C'est vrai quoi, moi je ne m'amuse jamais à modifier mes URL, et mes visiteurs non plus, je pense !

Oui, oui, trois fois oui : il faut que vous pensiez à gérer le cas où des paramètres que vous attendiez viendraient à manquer.

Vous vous souvenez de ce que je vous ai dit ? Il ne faut jamais faire confiance à l'utilisateur.

Tôt ou tard vous tomberez sur un utilisateur mal intentionné qui essaiera de trafiquer l'URL pour mettre n'importe quoi dans les paramètres. Il faut que votre site soit prêt à gérer le cas.

Dans notre exemple, si on ne gérait pas le cas, ça ne faisait rien de bien grave (ça affichait juste des messages d'erreur). Mais lorsque votre site web deviendra plus complexe, cela pourrait avoir des conséquences plus ennuyeuses.

Contrôlez la valeur des paramètres

Une fois les valeurs soumises et correctement récupérées, il faut vérifier qu'elles correspondent à ce qui est attendu !

Imaginez par exemple que l'utilisateur se soit trompé et que l'e-mail envoyé ne soit pas valide : vous ne pourrez donc pas le recontacter pour répondre à son besoin !

Il va donc falloir :

  - contrôler si l'e-mail passé est bien valide, à l'aide de la fonction filter_var ;

  - et vérifier que le message n'est pas vide, à l'aide de la fonction empty.

Voici donc le code final sécurisé, qui prévoit tous les cas pour éviter d'être pris au dépourvu par un utilisateur mal intentionné :

<?php
$getData = $_GET;

if (
    !isset($getData['email'])
    || !filter_var($getData['email'], FILTER_VALIDATE_EMAIL)
    || empty($getData['message'])
    || trim($getData['message']) === ''
) {
    echo('Il faut un email et un message valides pour soumettre le formulaire.');
    return;
}

Cela fait beaucoup de conditions pour quelque chose qui était à la base assez simple, mais c'était nécessaire. Vous devrez toujours faire très attention et prévoir tous les cas les plus tordus, comme nous venons de le faire :

  - vérifier que tous les paramètres que vous attendiez sont bien là ;

  - vérifier qu'ils contiennent des valeurs correctes, comprises dans des intervalles raisonnables.

Si vous gardez cela en tête, vous n'aurez pas de problèmes !

Nous n'avons pas détaillé le fonctionnement des fonctions filter_var ,  trim  et  empty .

N'hésitez pas à consulter tous les exemples de la documentation PHP pour bien comprendre son fonctionnement.

Exercez-vous

C'est à vous maintenant de valider les données du formulaire de contact (e-mail et message) dans notre projet fil rouge !

Vous pouvez retrouver le code modifié dans le dossier P3C1 du GitHub.

En résumé

- Une URL représente l'adresse d'une page web, commençant généralement par http://   .

- Lorsqu'on fait un lien vers une page, il est possible d'ajouter des paramètres sous la forme 
  bonjour.php?nom=Dupont&prenom=Jean qui seront transmis à la page.

- La page de réception recevra ces paramètres dans un tableau (array) nommé  $_GET  .

- Cette technique est très pratique pour transmettre des valeurs à une page, mais il faut prendre garde au 
  fait que le visiteur peut les modifier très facilement.

- La fonction isset() permet de vérifier si une variable est définie ou non.

- D'autres fonctions comme filter_var() ,  trim()  ou empty() peuvent être utilisées pour la validation des 
  champs.

Dans le prochain chapitre, nous allons voir comment administrer des formulaires de manière sécurisée. C'est parti !

##############################################################################################################

Administrez des formulaires de façon sécurisée

Les formulaires constituent le principal moyen pour vos visiteurs d'entrer des informations sur votre site. Dans le chapitre précédent, nous avions d'ailleurs abordé un premier formulaire de contact assez basique pour envoyer une URL avec des paramètres.

Dans ce chapitre, vous allez apprendre à faire des formulaires plus sécurisés.

Ce chapitre est particulièrement important ; nous réutiliserons ce que nous avons appris ici dans toute la suite du cours. Soyez attentif !

Ce chapitre suppose que vous êtes capable de créer des formulaires à l'aide du langage HTML. Si vous ne vous sentez pas prêt, pas de panique : il suffit de lire le chapitre sur les formulaires du cours HTML & CSS.

Rappelez-vous : la base du formulaire

En HTML, pour insérer un formulaire, on se sert de la balise  <form>  .

On l'utilise de la manière suivante :

<!-- index.php -->
<form method="post" action="submit_form.php">
 
<p>
    On insèrera ici les éléments de notre formulaire.
</p>
 
</form>
Il y a deux attributs très importants à connaître pour la balise <form>  :

  1. La méthode :  method  .

  2. Et la cible :  action  . 

Il est impératif que vous compreniez à quoi ils servent.

Privilégiez la méthode post pour envoyer les données du formulaire

Il faut savoir qu'il existe plusieurs moyens d'envoyer les données du formulaire (plusieurs « méthodes »).

Vous pouvez en employer deux :

  1. get : les données transiteront par l'URL, comme on l'a appris précédemment. On pourra les récupérer grâce 
     au tableau (array) $_GET  . Cette méthode est assez peu utilisée car on ne peut pas envoyer beaucoup 
     d'informations dans l'URL (je vous disais dans le chapitre précédent qu'il était préférable de ne pas 
     dépasser 256 caractères).

  2. post : les données ne transiteront pas par l'URL, l'utilisateur ne les verra donc pas passer dans la 
     barre d'adresse. Cette méthode permet d'envoyer autant de données que l'on veut, ce qui fait qu'on la 
     privilégie le plus souvent. Néanmoins, les données ne sont pas plus sécurisées qu'avec la méthode GET  , 
     et il faudra toujours vérifier si tous les paramètres sont bien présents et valides, comme on l'a fait 
     dans le chapitre précédent. On ne doit pas plus faire confiance aux formulaires qu'aux URL.

La bonne pratique consiste généralement à privilégier la méthode post pour les formulaires.

Choisissez la page appelée par le formulaire en définissant la cible

L'attribut action  sert à définir la page appelée par le formulaire. C'est cette page qui recevra les données du formulaire, et qui sera chargée de les traiter.

Selon la méthode utilisée, ce ne sera pas la même variable spéciale qui aura accès aux données :

  - Si la méthode est  GET  (comme dans le chapitre précédent), alors c'est la supervariable  $_GET qui aura 
    les données ;

  - Si la méthode est  POST  (bonne pratique), alors c'est la supervariable  $_POST  qui recevra les données.

Retenez donc bien que vous travaillez normalement sur deux pages différentes :

  1. La page qui contient le formulaire ( form.php  dans notre exemple) ;

  2. Et celle qui reçoit les données du formulaire pour les traiter ( submit_form.php  ).

Ajoutez un ou plusieurs champs input avec un attribut name

La variable  $_GET  sera complétée avec la valeur de l'attribut  name  en tant que clé, et aura pour valeur ce qui aura été soumis par l'utilisateur :

<input type="text" name="nom" value="Mateo21" />

<?php

// Après soumission du formulaire
echo $_GET['nom']; // "Mateo21"

// OU

echo $_POST['nom']; // "Mateo21"

Il y aura autant de clés dans le tableau $_GET que de champs avec un attribut name dans le formulaire soumis.

Faites attention avec les champs cachés

Les champs cachés constituent un type de champ à part.

En quoi ça consiste ?

C'est un code dans votre formulaire qui n'apparaîtra pas aux yeux du visiteur, mais qui va quand même créer une variable avec une valeur. On peut s'en servir pour transmettre des informations fixes.

Je m'explique : supposons que vous ayez besoin de « retenir » que le pseudo du visiteur est « Mateo21 ». Vous allez taper ce code :

<input type="hidden" name="pseudo" value="Mateo21" />

À l'écran, sur la page web on ne verra rien. Mais dans la page cible, une variable $_POST['pseudo'] sera créée, et elle aura la valeur « Mateo21 » !

C'est apparemment inutile, mais vous verrez que vous en aurez parfois besoin.

On croit par erreur que, parce que ces champs sont cachés, le visiteur ne peut pas les voir. C'est faux ! En effet, n'importe quel visiteur peut afficher le code source de la page pour voir et modifier les champs cachés en lisant le code HTML.

Ne faites jamais confiance aux données reçues : la faille XSS

Vous vous souvenez des mises en garde que j'avais faites dans le chapitre précédent ? Elles ne concernaient pas que les paramètres qui transitent par l'URL : tout cela vaut aussi pour les formulaires !

Je vois comment on peut modifier l'URL, mais comment peut faire un visiteur pour modifier le formulaire de mon site et trafiquer les données ?

J'y viens…

La faille XSS : attention au code HTML que vous recevez !

La sécurité des applications web est un sujet très important à maîtriser lors de votre apprentissage. Si vous souhaitez en savoir plus sur le sujet, consultez le cours "Sécurisez vos applications web avec l'OWASP".

La faille XSS (pour cross-site scripting) est vieille comme le monde (euh, comme le Web) et on la trouve encore sur de nombreux sites web, même professionnels ! C'est une technique qui consiste à injecter du code HTML contenant du JavaScript dans vos pages, pour le faire exécuter à vos visiteurs.

Reprenons la page de récapitulatif qui affiche l'e-mail et le message qu'on a soumis dans le chapitre précédent :

<h5>Rappel de vos informations</h5>
<p><b>Email</b> : <?php echo $_POST['email']; ?></p>
<p><b>Message</b> : <?php echo $_POST['message']; ?></p>

Si le visiteur décide d'écrire du code HTML dans la zone de message, cela fonctionnera très bien !

Par exemple, imaginons qu'il écrive dans le champ « Votre message » le code :<strong>Badaboum</strong>

Le code source HTML qui sera généré par PHP sera le suivant :

<p><b>Message</b> : <strong>Badaboum</strong></p>

Et alors ? S'il veut mettre son message en gras, c'est son problème, non ?

Outre le fait qu'il peut insérer n'importe quel code HTML (et rendre votre page invalide), ce qui n'est pas le plus grave, il peut aussi ouvrir des balises de type <script> pour faire exécuter du code JavaScript au visiteur qui visualisera la page !

<p><b>Message</b> : <script>alert('Badaboum')</script></p>

Tous les visiteurs qui arriveront sur cette page verront une boîte de dialogue JavaScript s'afficher. Plutôt gênant. Voyez la figure suivante.

Sécurisez votre code en bloquant l'exécution de code JavaScript

Pour ignorer le code HTML, il suffit d'utiliser la fonction  htmlspecialchars  .

On dira dans ce cas qu'on "échappe" le code HTML, c'est-à-dire que la fonction JavaScript alert() n'en tiendra pas compte.

Elle va transformer les chevrons des balises HTML  <  et  >  en &lt;  et &gt;  respectivement.

Cela provoquera l'affichage de la balise plutôt que son exécution.

<p><b>Message</b> : <?php echo htmlspecialchars($_POST['message']); ?></p>

Le code HTML qui en résultera sera propre et protégé, car les balises HTML insérées par le visiteur auront été échappées :

<p><b>Message</b> : &lt;strong&gt;Badaboum&lt;/strong&gt; ?></p>

Il faut penser à utiliser cette fonction sur tous les textes envoyés par l'utilisateur qui sont susceptibles d'être affichés sur une page web.

Bref, tout ce qui est affiché et qui vient, à la base, d'un visiteur, vous devez penser à le protéger avec  htmlspecialchars  .

Si vous préférez retirer les balises HTML que le visiteur a tenté d'envoyer plutôt que de les afficher, utilisez la fonction  strip_tags  .

Voici donc une nouvelle version du code de réception du formulaire (avec method="POST"  ) sécurisée, qui prévoit tous les cas pour éviter d'être pris au dépourvu par un utilisateur mal intentionné :

<?php
/**
* On ne traite pas les super globales provenant de l'utilisateur directement,
* ces données doivent être testées et vérifiées.
*/
$postData = $_POST;

if (
    !isset($postData['email'])
    || !filter_var($postData['email'], FILTER_VALIDATE_EMAIL)
    || empty($postData['message'])
    || trim($postData['message']) === ''
) {
    echo('Il faut un email et un message valides pour soumettre le formulaire.');
    return;
}
?>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site de Recettes - Contact reçu</title>
    <link
href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
rel="stylesheet"
>
</head>

<body>
    <div class="container">
        <?php require_once(__DIR__ . '/header.php'); ?>
        <h1>Message bien reçu !</h1>
        <div class="card">
        <div class="card-body">
            <h5 class="card-title">Rappel de vos informations</h5>
            <p class="card-text"><b>Email</b> : <?php echo($postData['email']); ?></p>
            <p class="card-text"><b>Message</b> : <?php echo(strip_tags($postData['message'])); ?></p>
        </div>
    </div>
</body>
</html>

Exercez-vous

Il est temps de refaire les modifications par vous-même et d'utiliser  POST  à la place de  GET .

Vous pouvez retrouver le code modifié dans le dossier P3C2 du GitHub.

En résumé

- Les formulaires sont le moyen le plus pratique pour le visiteur de transmettre des informations à votre 
  site. PHP est capable de récupérer les données saisies par vos visiteurs et de les traiter.

- Les données envoyées via un formulaire se retrouvent dans un tableau (array)  $_POST  .

- De la même manière que pour les URL, il ne faut pas donner sa confiance absolue aux données que vous envoie 
  l'utilisateur. Traitez les données reçues avec vigilance.

- Que ce soit pour des données issues de l'URL ( $_GET  ) ou d'un formulaire ( $_POST  ), il faut s'assurer 
  qu'aucun texte qui vous est envoyé ne contient du HTML si celui-ci est destiné à être affiché sur une page. 
  Sinon, vous ouvrez une faille appelée XSS qui peut être néfaste pour la sécurité de votre site.

- Pour éviter la faille XSS, il suffit d'appliquer la fonction htmlspecialchars  ou  strip_tags sur tous les 
  textes envoyés par vos visiteurs que vous afficherez.

Dans le prochain chapitre, nous allons voir comment permettre aux utilisateurs de votre site de partager et d'envoyer des fichiers. On y va !

##############################################################################################################

Activez le partage de fichiers

Imaginez qu'une personne essaie de vous contacter car elle est victime d'un bug d'utilisation sur votre site : elle souhaiterait peut-être vous partager une capture d'écran, ce qui faciliterait beaucoup votre travail de déboggage.

Pour cela, vous allez devoir proposer la soumission de fichiers dans votre formulaire de contact !

Vous aviez découvert les superglobales  $_GET  et  $_POST  dans les chapitres précédents, c'est maintenant au tour de la supervariable  $_FILES  de faire son entrée dans votre projet !

Donnez la possibilité d'envoyer des fichiers

Vous saviez qu'on pouvait aussi envoyer des fichiers grâce aux formulaires ?

Là encore, ça se passe en deux temps.

  1. Le visiteur arrive sur votre formulaire et le remplit (en indiquant le fichier à envoyer). Une simple 
     page HTML suffit pour créer le formulaire.

  2. PHP réceptionne les données du formulaire et, s'il y a des fichiers dedans, il les « enregistre » dans un 
     des dossiers du serveur.

Attention : l'envoi du fichier peut être un peu long si celui-ci est gros. Il faudra dire au visiteur de ne pas s'impatienter pendant l'envoi.

Vous allez devoir adapter votre formulaire de contact pour autoriser l'envoi et la soumission.

Paramétrez le formulaire d'envoi de fichier
Dès l'instant où votre formulaire propose aux visiteurs d'envoyer un fichier, il faut ajouter l'attribut enctype="multipart/form-data" à la balise  <form>  .

<form action="submit_contact.php" method="POST" enctype="multipart/form-data">
    <!-- champs de formulaire -->
</form>

Grâce à enctype , le navigateur du visiteur sait qu'il s'apprête à envoyer des fichiers.

Maintenant que c'est fait, nous pouvons ajouter à l'intérieur du formulaire une balise permettant d'envoyer un fichier.

C'est une balise très simple de type   <input type="file" />  .

Il faut donner un nom à ce champ de formulaire (grâce à l'attribut name ) pour que PHP puisse reconnaître le champ par la suite.

<form action="submit_contact.php" method="POST" enctype="multipart/form-data">
    <!-- Ajout des champs email et message -->
    [...]
    <!-- Ajout champ d'upload ! -->
    <div class="mb-3">
        <label for="screenshot" class="form-label">Votre capture d'écran</label>
        <input type="file" class="form-control" id="screenshot" name="screenshot" />
    </div>
    <!-- Fin ajout du champ -->
    <button type="submit" class="btn btn-primary">Envoyer</button>
</form>

Voilà, c'est suffisant.

Traitez l'envoi en PHP

C'est maintenant que ça devient important. Il faut que l'on ajoute du code dans la page submit_contact.php pour traiter l'envoi du fichier.

« Traiter l'envoi du fichier » ? C'est-à-dire ? Si le fichier a été envoyé sur le serveur, c'est bon, non ? Qu'est-ce que PHP aurait besoin de faire ?

En fait, au moment où la page PHP s'exécute, le fichier a été envoyé sur le serveur mais il est stocké dans un dossier temporaire.

C'est à vous de décider si vous acceptez définitivement le fichier ou non.

Vous pouvez par exemple vérifier si le fichier a la bonne extension (si vous demandez une image et qu'on vous envoie un « .txt », vous devrez refuser le fichier).

Si le fichier est bon, vous l'accepterez grâce à la fonction move_uploaded_file et ce, d'une manière définitive.

Mais comment je sais si « le fichier est bon » ?

Pour chaque fichier envoyé, une variable $_FILES['nom_du_champ'] est créée.

Dans notre cas, la variable s'appellera $_FILES['screenshot'] 

Cette variable est un tableau qui contient plusieurs informations sur le fichier :


Variable                               Signification

$_FILES['screenshot']['name']          Contient le nom du fichier envoyé par le visiteur.

$_FILES['screenshot']['type']          Indique le type du fichier envoyé. Si c'est une image gif par exemple, 
                                       le type sera image/gif

$_FILES['screenshot']['size']          Indique la taille du fichier envoyé.

                                       Attention : cette taille est en octets. Il faut environ 1 000 octets 
                                       pour faire 1 Ko, et 1 000 000 d'octets pour faire 1 Mo.
                                       La taille de l'envoi est limitée par PHP. Par défaut, impossible 
                                       d'uploader des fichiers de plus de 8 Mo.

$_FILES['screenshot']['tmp_name']      Juste après l'envoi, le fichier est placé dans un répertoire temporaire 
                                       sur le serveur en attendant que votre script PHP décide si oui ou non 
                                       il accepte de le stocker pour de bon. Cette variable contient 
                                       l'emplacement temporaire du fichier (c'est PHP qui gère ça).

$_FILES['screenshot']['error']         Contient un code d'erreur permettant de savoir si l'envoi s'est bien 
                                       effectué ou s'il y a eu un problème et si oui, lequel. La variable vaut 
                                       0 s'il n'y a pas eu d'erreur.



Si vous avez mis un second champ d'envoi de fichier dans votre formulaire, il y aura une seconde variable $_FILES['nom_de_votre_autre_champ'] découpée de la même manière que le tableau qu'on vient de voir ici.

$_FILES['nom_de_votre_autre_champ']['size'] contiendra donc la taille du second fichier, et ainsi de suite.

Je vous propose de faire les vérifications suivantes pour décider si l'on accepte le fichier ou non.

  1. Vérifier tout d'abord si le visiteur a bien envoyé un fichier, en testant la variable 
     $_FILES['screenshot'] avec isset() et s'il n'y a pas eu d'erreur d'envoi, grâce à 
     $_FILES['screenshot']['error'] .

  2. Vérifier si la taille du fichier ne dépasse pas 1 Mo par exemple (environ 1 000 000 d'octets), grâce à 
     $_FILES['screenshot']['size']  .

  3. Vérifier si l'extension du fichier est autorisée (il faut interdire à tout prix que les gens puissent 
     envoyer des fichiers PHP, sinon ils pourraient exécuter des scripts sur votre serveur). Dans notre cas, 
     nous autoriserons seulement les images (fichiers .png, .jpg, .jpeg et .gif).
     Nous analyserons pour cela la variable $_FILES['screenshot']['name'] .

Nous allons donc faire une série de tests dans notre page submit_contact.php .

1/ Testez si le fichier a bien été envoyé
On commence par vérifier qu'un fichier a été envoyé.

Pour cela, on va tester si la variable $_FILES['screenshot']  existe avec  isset()  .

On vérifie dans le même temps s'il n'y a pas d'erreur d'envoi.

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas d'erreur
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] == 0)
{
 
}
?>

2/ Vérifiez la taille du fichier
On veut interdire que le fichier dépasse 1 Mo, soit environ 1 000 000 d'octets (j'arrondis pour simplifier). On doit donc tester $_FILES['screenshot']['size'] :

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }
}

3/ Vérifiez l'extension du fichier
On peut récupérer l'extension du fichier dans une variable grâce à ce code :

<?php
$fileInfo = pathinfo($_FILES['screenshot']['name']);
$extension = $fileInfo['extension'];
?>

La fonction pathinfo renvoie un tableau (array) contenant entre autres l'extension du fichier dans  $fileInfo['extension']  .

On stocke ça dans une variable  $extension  .

Une fois l'extension récupérée, on peut la comparer à un tableau d'extensions autorisées, et vérifier si l'extension récupérée fait bien partie des extensions autorisées à l'aide de la fonction in_array() .

Ouf ! On obtient ce code :

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }
    
    // Testons, si l'extension n'est pas autorisée
    $fileInfo = pathinfo($_FILES['screenshot']['name']);
    $extension = $fileInfo['extension'];
    $allowedExtensions = ['jpg', 'jpeg', 'gif', 'png'];
    if (!in_array($extension, $allowedExtensions)) {
        echo "L'envoi n'a pas pu être effectué, l'extension {$extension} n'est pas autorisée";
        return;
    }
}

4/ Vérifiez si le dossier pour stocker les images existe
Je propose de placer le fichier dans un sous-dossier « uploads ». Pour vérifier si notre dossier uploads existe, nous allons utiliser la fonction  is_dir()  . Il nous suffit de lui fournir le chemin du dossier que nous souhaitons tester. La fonction renvoie true si le dossier existe et false dans le cas contraire.

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }

    // Testons, si l'extension n'est pas autorisée
    $fileInfo = pathinfo($_FILES['screenshot']['name']);
    $extension = $fileInfo['extension'];
    $allowedExtensions = ['jpg', 'jpeg', 'gif', 'png'];
    if (!in_array($extension, $allowedExtensions)) {
        echo "L'envoi n'a pas pu être effectué, l'extension {$extension} n'est pas autorisée";
        return;
    }

    // Testons, si le dossier uploads est manquant
    $path = __DIR__ . '/uploads/';
    if (!is_dir($path)) {
        echo "L'envoi n'a pas pu être effectué, le dossier uploads est manquant";
        return;
    }
}

5/ Validez l'upload du fichier
Si tout est bon, on accepte le fichier en appelant   move_uploaded_file()  .

Cette fonction prend deux paramètres :

  1. Le nom temporaire du fichier (on l'a avec  $_FILES['screenshot']['tmp_name']  ).

  2. Le chemin qui est le nom sous lequel sera stocké le fichier de façon définitive. On peut utiliser le nom 
     d'origine du fichier  $_FILES['screenshot']['name']  ou générer un nom au hasard.

On gardera le même nom de fichier que celui d'origine.

Comme  $_FILES['screenshot']['name']  contient le chemin entier vers le fichier d'origine (  C:\dossier\fichier.png  , par exemple), il nous faudra extraire le nom du fichier.

On peut utiliser pour cela la fonction  basename  qui renverra juste « fichier.png ».

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }
    // Testons, si l'extension n'est pas autorisée
    $fileInfo = pathinfo($_FILES['screenshot']['name']);
    $extension = $fileInfo['extension'];
    $allowedExtensions = ['jpg', 'jpeg', 'gif', 'png'];
    if (!in_array($extension, $allowedExtensions)) {
        echo "L'envoi n'a pas pu être effectué, l'extension {$extension} n'est pas autorisée";
        return;
    }
    // Testons, si le dossier uploads est manquant
    $path = __DIR__ . '/uploads/';
    if (!is_dir($path)) {
        echo "L'envoi n'a pas pu être effectué, le dossier uploads est manquant";
        return;
    }
    // On peut valider le fichier et le stocker définitivement
    move_uploaded_file($_FILES['screenshot']['tmp_name'], $path . basename($_FILES['screenshot']['name']));
}

Lorsque vous mettrez le script sur Internet à l'aide d'un logiciel FTP, vérifiez que le dossier « Uploads » sur le serveur existe, et qu'il a les droits d'écriture. Pour ce faire, sous FileZilla par exemple, faites un clic droit sur le dossier et choisissez « Attributs du fichier ».
Cela vous permettra d'éditer les droits du dossier (on parle de CHMOD). Mettez les droits à 733, ainsi PHP pourra placer les fichiers téléversés dans ce dossier.

Ce script est un début, mais en pratique il vous faudra sûrement encore l'améliorer.

Par exemple, si le nom du fichier contient des espaces ou des accents, ça posera un problème une fois envoyé sur le Web. D'autre part, si quelqu'un envoie un fichier qui a le même nom que celui d'une autre personne, l'ancien sera écrasé !

La solution consiste en général à « choisir » nous-mêmes le nom du fichier stocké sur le serveur, plutôt que de nous servir du nom d'origine. Vous pouvez faire un compteur qui s'incrémente : 1.png, 2.png, 3.jpg, etc.

Soyez toujours très vigilant sur la sécurité ; vous devez éviter que quelqu'un puisse envoyer des fichiers PHP sur votre serveur.

Exercez-vous

Il nous reste à apporter une modification supplémentaire pour que notre affichage prenne en compte le chargement du fichier.

Étant donné que le champ d'image n'est pas obligatoire dans notre formulaire, nous afficherons le message suivant "L'envoi a bien été effectué !" uniquement si une image a été téléchargée.

Vous pouvez retrouver le code modifié dans le dossier P3C3 du GitHub.

En résumé

- Les formulaires permettent d'envoyer des fichiers. On retrouve les informations sur les fichiers envoyés 
  dans un array $_FILES . Leur traitement est cependant plus complexe.

- Il faudra toujours contrôler les fichiers reçus : leur existence et leur taille qui est soumise à limitation 
  par la configuration de PHP.

- Il faudra vérifier leur extension (à l'aide de la fonction pathinfo) et surtout refuser tout fichier PHP qui 
  pourrait par la suite s'exécuter sur votre serveur.

- À l'aide de la fonction move_uploaded_file, vous pouvez conserver le fichier téléversé sur votre serveur, 
  mais vérifiez bien que vous avez les droits d'écrire des fichiers d'abord.

Dans le prochain chapitre, nous allons voir comment implémenter un système de connexion pour vos utilisateurs. 

##############################################################################################################

Implémentez un système de connexion

Croyez-le ou non, vous avez déjà le niveau pour protéger le contenu d'une page par mot de passe ! C'est ce que je vais vous apprendre à faire dans ce chapitre.

Voici la liste des connaissances que vous allez devoir mobiliser pour cela :

  - afficher du texte avec echo ;

  - utiliser les variables  ;

  - transmettre des variables via une zone de texte d'un formulaire ;

  - utiliser des conditions simples ( if , else  ) ;

  - utiliser les inclusions de fichiers avec include ou include_once .

Si l'un de ces points est un peu flou pour vous (vous avez peut-être oublié), n'hésitez pas à relire le chapitre correspondant.

Le but est de parvenir à assembler toutes vos connaissances pour répondre à un problème précis.

Protégez le contenu d'une page par un mot de passe

Vous voulez que les contributeurs et contributrices de recettes puissent se connecter sur votre site et être reconnus.

Pour faire simple, il y aura un formulaire de connexion avec e-mail et mot de passe et une fois la personne connectée, nous afficherons un message du type :

"Bonjour utilisateur@exemple.com et bienvenue sur le site !"

Et nous rajoutons une contrainte : la liste des recettes ne sera affichée que si l'utilisateur est connecté !

Les utilisateurs seront déjà disponibles sous forme d'un tableau associatif PHP. Ils ont :

  1. Une clé 'password' avec un mot de passe.

  2. Et une clé 'email' avec leur e-mail.

Travaillez d'abord au brouillon

Pour coder correctement, je recommande toujours de travailler d'abord au brouillon (vous savez, avec un stylo et une feuille de papier !). Ça peut bien souvent paraître une perte de temps, mais c'est tout à fait le contraire.

Si vous vous mettez à écrire des lignes de code au fur et à mesure, ça va être à coup sûr le bazar. À l'inverse, si vous prenez cinq minutes pour y réfléchir devant une feuille de papier, votre code sera mieux structuré et vous éviterez de nombreuses erreurs (qui font, elles, perdre du temps).

À quoi doit-on réfléchir sur notre brouillon ?

  1. Au problème que vous vous posez (qu'est-ce que je veux arriver à faire ?).

  2. Au schéma du code, c'est-à-dire que vous allez commencer à le découper en plusieurs morceaux, eux-mêmes 
     découpés en petits morceaux (c'est plus facile à avaler).

  3. Aux fonctions et aux connaissances en PHP dont vous allez avoir besoin (pour être sûr que vous les 
     utilisez convenablement).

Et pour montrer l'exemple, nous allons suivre cette liste.

1. Posez le problème

On doit soumettre un e-mail et un mot de passe dans un formulaire de connexion.

Si le formulaire est valide, nous affichons un message de succès, et sinon un message d'erreur. La liste de recettes n'est affichée qu'à un utilisateur qui s'est connecté avec succès.

2. Schématisez le code

Pour que l'utilisateur puisse entrer le mot de passe, le plus simple est de créer un formulaire. Celui-ci sera directement intégré dans la page d'accueil du site telle que nous la connaissons déjà.

Trois situations peuvent survenir :

  1. Vous n'êtes pas connecté : auquel cas, le formulaire de contact s'affiche, et la liste des recettes ne 
     s'affiche pas.

  2. Vous avez soumis le formulaire avec le bon mot de passe pour l'utilisateur : le message de succès 
     s'affiche, le formulaire de connexion ne s'affiche pas et les recettes s'affichent.

  3. Vous avez soumis le formulaire avec le mauvais mot de passe pour l'utilisateur : le message d'erreur 
     s'affiche, le formulaire de connexion s'affiche et les recettes ne s'affichent pas.

Vous devez donc créer une nouvelle page et adapter la page d'accueil :

  - login.php : contient un simple formulaire comme vous savez les faire ;

  - index.php : qui doit maintenant inclure un formulaire de connexion et une condition sur l'affichage des 
                recettes.

3. Mobilisez les connaissances requises
Nous avons détaillé les connaissances requises au début de ce chapitre. Vous allez voir que ce n'est qu'une simple application pratique de ce que vous connaissez déjà, mais cela sera une bonne occasion de vous entraîner.

Bon ! On a préparé le terrain ensemble ; maintenant, vous savez tout ce qu'il faut pour réaliser le script !

Vous êtes normalement capable de trouver le code à écrire par vous-même, et c'est ce que je vous invite à faire. Ça ne marchera peut-être pas du premier coup, mais ne vous en faites pas : c'est le métier qui rentre !

Au secours, je n'y arrive pas, comment on fait ?

Pas de panique ! Voyons tout cela ensemble.

Comme vous le savez, il y a deux pages à créer :

  - La page login.php.

  - La page index.php.

Codez la page login.php

Commençons par la plus simple, login.php :

<?php

/**
 * On ne traite pas les super globales provenant de l'utilisateur directement,
 * ces données doivent être testées et vérifiées.
 */

$postData = $_POST;


// Validation du formulaire
if (isset($postData['email']) &&  isset($postData['password'])) {
	if (!filter_var($postData['email'], FILTER_VALIDATE_EMAIL)) {
    	$errorMessage = 'Il faut un email valide pour soumettre le formulaire.';
	} else {
    	foreach ($users as $user) {
        	if (
            	$user['email'] === $postData['email'] &&
            	$user['password'] === $postData['password']
        	) {
            	$loggedUser = [
                	'email' => $user['email'],
            	];
        	}
    	}

    	if (!isset($loggedUser)) {
        	$errorMessage = sprintf(
            	'Les informations envoyées ne permettent pas de vous identifier : (%s/%s)',
            	$postData['email'],
            	strip_tags($postData['password'])
        	);
    	}
	}
}
?>

	<!--
   	Si utilisateur/trice est non identifié(e), on affiche le formulaire
	-->
<?php if (!isset($loggedUser)) : ?>
	<form action="index.php" method="POST">
    	<!-- si message d'erreur on l'affiche -->
    	<?php if (isset($errorMessage)) : ?>
        	<div class="alert alert-danger" role="alert">
            	<?php echo $errorMessage; ?>
        	</div>
    	<?php endif; ?>
    	<div class="mb-3">
        	<label for="email" class="form-label">Email</label>
        	<input type="email" class="form-control" id="email" name="email" aria-describedby="email-help" placeholder="you@exemple.com">
        	<div id="email-help" class="form-text">L'email utilisé lors de la création de compte.</div>
    	</div>
    	<div class="mb-3">
        	<label for="password" class="form-label">Mot de passe</label>
        	<input type="password" class="form-control" id="password" name="password">
    	</div>
    	<button type="submit" class="btn btn-primary">Envoyer</button>
	</form>
	<!-- Si utilisateur/trice bien connectée on affiche un message de succès -->
<?php else : ?>
	<div class="alert alert-success" role="alert">
    	Bonjour <?php echo $loggedUser['email']; ?> et bienvenue sur le site !
	</div>
<?php endif; ?>

J'ai choisi un champ de type password puisqu'il s'agit d'un mot de passe. À part ça, rien de bien particulier.

Codez la page index.php

Maintenant, intéressons-nous à la page index.php qui va inclure le formulaire et limiter l'accès aux recettes :

<!-- inclusion des variables et fonctions -->
<?php
require_once(__DIR__ . '/variables.php');
require_once(__DIR__ . '/functions.php');
?>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site de recettes - Page d'accueil</title>
    <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
            rel="stylesheet"
    >
</head>
<body class="d-flex flex-column min-vh-100">
    <div class="container">
        <!-- inclusion de l'entête du site -->
        <?php require_once(__DIR__ . '/header.php'); ?>
        <h1>Site de recettes</h1>

        <!-- Formulaire de connexion -->
        <?php require_once(__DIR__ . '/login.php'); ?>

        <?php if (isset($loggedUser)) : ?>
            <?php foreach (getRecipes($recipes) as $recipe) : ?>
                <article>
                    <h3><?php echo $recipe['title']; ?></h3>
                    <div><?php echo $recipe['recipe']; ?></div>
                    <i><?php echo displayAuthor($recipe['author'], $users); ?></i>
                </article>
            <?php endforeach ?>
        <?php endif; ?>
    </div>

    <!-- inclusion du bas de page du site -->
    <?php require_once(__DIR__ . '/footer.php'); ?>
</body>
</html>

Pour le résultat suivant :

Mais est-ce que le formulaire est si sécurisé que ça ?

Oui, honnêtement il l'est. Du moins, tant que vos utilisateurs ne choisissent pas de mots de passe trop simples à deviner !

Pour moi, un bon mot de passe c'est long, avec plein de caractères bizarres, des majuscules, des minuscules, des chiffres, etc. Par exemple, k7hYTe40Lm8Mf  est un bon mot de passe qui a peu de chances d'être trouvé « par hasard ».

Allez plus loin

Pour l'instant ce système de connexion n'est pas "persistant". C'est-à-dire que si vous rechargez la page d'accueil ou que vous revenez sur votre site plus tard, l'information de la connexion n'aura pas été conservée.

Pas super utile du coup ! Comment on fait pour conserver les informations de connexion d'un utilisateur ?

Eh bien, ce sera l'objet des prochains chapitres !

Exercez-vous

Il ne vous reste plus qu'à modifier le projet pour implémenter le système de connexion. C'est parti !

Vous pouvez retrouver le code modifié dans le dossier P3C4 du GitHub.

En résumé

- Il est recommandé de passer des informations en POST lorsqu'on conçoit un formulaire de connexion.

- Soit l'utilisateur est identifiable, c'est-à-dire que l'on retrouve une correspondance avec les identifiants 
  fournis ; auquel cas, on autorise l'affichage du contenu.

- Soit l'utilisateur n'est pas identifiable : alors, on affichera un message d'erreur !

Dans le prochain chapitre, nous allons voir comment conserver les données grâce aux sessions et aux cookies. À tout de suite !

##############################################################################################################

Conservez des données grâce aux sessions et aux cookies

Dans le chapitre précédent, vous avez mis en place un système de connexion. Il fonctionne certes, mais il ne conserve pas l'information !

Dans ce chapitre, vous allez apprendre à manipuler deux notions qui permettent de conserver l'information entre deux pages PHP pour une durée plus ou moins longue. Bienvenue dans le monde des données persistantes, un sujet qui va nous occuper jusqu'à la fin de ce cours !

À la fin de ce chapitre, vous disposerez d'un système de connexion entièrement fonctionnel.

Conservez les données grâce aux sessions

Jusqu'ici, nous étions parvenus à passer des variables de page en page à l'aide d'URL ou de formulaires. On sait ainsi envoyer d'une page à une autre le nom et le prénom du visiteur. Mais dès qu'on charge une autre page, ces informations sont « oubliées ». C'est pour cela qu'on a inventé les sessions.

Les sessions permettent de conserver des variables sur toutes les pages de votre site. 

Comprenez le fonctionnement des sessions

Comment sont gérées les sessions en PHP ?

Voici les trois étapes à connaître :

Étape 1 : création d'une session unique

  1. Un visiteur arrive sur votre site.

  2. On demande à créer une session pour lui.

  3. PHP génère alors un numéro unique.

Ce numéro est souvent très grand. Exemple : a02bbffc6198e6e0cc2715047bc3766f.

Ce numéro sert d'identifiant ; c'est ce qu'on appelle un « ID de session » ou  PHPSESSID  .

PHP transmet automatiquement cet ID de page en page, en utilisant généralement un cookie.

Étape 2 : création de variables pour la session

Une fois la session générée, on peut créer une infinité de variables de session pour nos besoins.

Par exemple, on peut créer :

   - une variable qui contient le nom du visiteur : $_SESSION['nom'] 

   - une autre qui contient son prénom : $_SESSION['prenom'] 

   - etc.

Le serveur conserve ces variables même lorsque la page PHP a fini d'être générée. Autrement dit : quelle que soit la page de votre site, vous pourrez récupérer le nom et le prénom du visiteur via la superglobale $_SESSION !

Étape 3 : suppression de la session

Lorsque le visiteur se déconnecte de votre site, la session est fermée et PHP « oublie » alors toutes les variables de session que vous avez créées.

Il est en fait difficile de savoir précisément quand un visiteur quitte votre site. En effet, lorsqu'il ferme son navigateur ou va sur un autre site, le vôtre n'en est pas informé.

Soit le visiteur clique sur un bouton « Déconnexion » (que vous aurez créé) avant de s'en aller, soit on attend quelques minutes d'inactivité pour le déconnecter automatiquement : on parle alors de "timeout". Le plus souvent, le visiteur est déconnecté par un timeout.

Pour activer ou détruire une session, deux fonctions sont à connaître :

  1. session_start() : démarre le système de sessions. Si le visiteur vient d'arriver sur le site, alors un 
                       numéro de session est généré pour lui. 

  2. session_destroy() : ferme la session du visiteur. Cette fonction est automatiquement appelée lorsque le 
                         visiteur ne charge plus de page de votre site pendant plusieurs minutes (c'est le 
                         timeout), mais vous pouvez aussi créer une page « Déconnexion » si le visiteur 
                         souhaite se déconnecter manuellement.

Il faut appeler session_start() sur chacune de vos pages AVANT d'écrire le moindre code HTML ou PHP (avant même la balise  <!DOCTYPE>  ). 

Si vous oubliez de lancer session_start()  , vous ne pourrez pas accéder à la variable superglobale   $_SESSION  .

Mettez en place une session

Je vous propose d'étudier un exemple concret pour que vous voyiez à quel point c'est simple à utiliser, en mettant en place une session pour conserver l'information sur l'utilisateur connecté après connexion :

Si vous voulez détruire manuellement la session du visiteur, vous pouvez faire un lien « Déconnexion » amenant vers une page qui fait appel à la fonction  session_destroy()  .

Néanmoins, sachez que sa session sera automatiquement détruite au bout d'un certain temps d'inactivité.

Concrètement, les sessions peuvent servir dans de nombreux cas sur votre site (et pas seulement pour retenir un nom et un prénom !).

Voici quelques exemples :

  - Imaginez un script qui demande un identifiant et un mot de passe pour qu'un visiteur puisse se 
    « connecter » (s'authentifier). On peut enregistrer ces informations dans des variables de session et se 
    souvenir de l'identifiant du visiteur sur toutes les pages du site !

  - Puisqu'on retient son identifiant et que la variable de session n'est créée que s'il a réussi à 
    s'authentifier, on peut l'utiliser pour restreindre certaines pages de notre site à certains visiteurs 
    uniquement. Cela permet de créer toute une zone d'administration sécurisée : si la variable de session 
    login existe, on affiche le contenu, sinon on affiche une erreur. Cela devrait vous rappeler l'exercice 
    sur la protection d'une page par mot de passe, sauf qu'ici, on peut se servir des sessions pour protéger 
    automatiquement plusieurs pages.

  - On se sert activement des sessions sur les sites de vente en ligne. Cela permet de gérer un « panier » : 
    on retient les produits que commande le client quelle que soit la page où il est. Lorsqu'il valide sa 
    commande, on récupère ces informations et… on le fait payer. 

Apportons des modifications à notre projet

Nous allons effectuer plusieurs ajustements sur notre projet afin de le préparer pour la suite de ce cours.

1. Affichons les recettes même si l'utilisateur n'est pas connecté.

Dans le chapitre précédent, nous avions limité l'affichage des recettes aux utilisateurs connectés pour que vous ayez des bases solides pour la suite. Cependant, dans la vraie vie, nous souhaitons que nos recettes soient visibles par tous. Par conséquent, nous allons afficher à nouveau nos recettes. Modifions index.php :

<!-- inclusion des variables et fonctions -->

<?php
session_start();
require_once(__DIR__ . '/variables.php');
require_once(__DIR__ . '/functions.php');
?>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site de recettes - Page d'accueil</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="d-flex flex-column min-vh-100">
    <div class="container">
        <!-- inclusion de l'entête du site -->
        <?php require_once(__DIR__ . '/header.php'); ?>
        <h1>Site de recettes</h1>

        <!-- Formulaire de connexion -->
        <?php require_once(__DIR__ . '/login.php'); ?>

        <?php foreach (getRecipes($recipes) as $recipe) : ?>
            <article>
                <h3><?php echo $recipe['title']; ?></h3>
                <div><?php echo $recipe['recipe']; ?></div>
                <i><?php echo displayAuthor($recipe['author'], $users); ?></i>
            </article>
        <?php endforeach ?>
    </div>

    <!-- inclusion du bas de page du site -->
    <?php require_once(__DIR__ . '/footer.php'); ?>
</body>
</html>

2. Séparons notre fichier login.php en deux fichiers, tout comme nous l'avons fait pour le formulaire de contact.

Dans le fichier login.php, nous allons afficher notre formulaire de connexion :

<!--
   Si utilisateur/trice est non identifié(e), on affiche le formulaire
-->

<?php if (!isset($_SESSION['LOGGED_USER'])) : ?>
    <form action="submit_login.php" method="POST">
        <!-- si message d'erreur on l'affiche -->
        <?php if (isset($_SESSION['LOGIN_ERROR_MESSAGE'])) : ?>
            <div class="alert alert-danger" role="alert">
                <?php echo $_SESSION['LOGIN_ERROR_MESSAGE'];
                unset($_SESSION['LOGIN_ERROR_MESSAGE']); ?>
            </div>
        <?php endif; ?>
        <div class="mb-3">
            <label for="email" class="form-label">Email</label>
            <input type="email" class="form-control" id="email" name="email" aria-describedby="email-help" placeholder="you@exemple.com">
            <div id="email-help" class="form-text">L'email utilisé lors de la création de compte.</div>
        </div>
        <div class="mb-3">
            <label for="password" class="form-label">Mot de passe</label>
            <input type="password" class="form-control" id="password" name="password">
        </div>
        <button type="submit" class="btn btn-primary">Envoyer</button>
    </form>

    <!-- Si utilisateur/trice bien connectée on affiche un message de succès -->
<?php else : ?>
    <div class="alert alert-success" role="alert">
        Bonjour <?php echo $_SESSION['LOGGED_USER']['email']; ?> et bienvenue sur le site !
    </div>
<?php endif; ?>

Désormais, lors de la soumission du formulaire, nous appellerons le fichier submit_login.php :

<form action="submit_login.php" method="POST">

Ensuite, nous allons transférer le traitement du formulaire dans le fichier submit_login.php :

<?php
session_start();
require_once(__DIR__ . '/variables.php');
require_once(__DIR__ . '/functions.php');

/**
 * On ne traite pas les super globales provenant de l'utilisateur directement,
 * ces données doivent être testées et vérifiées.
 */
$postData = $_POST;

// Validation du formulaire
if (isset($postData['email']) &&  isset($postData['password'])) {
if (!filter_var($postData['email'], FILTER_VALIDATE_EMAIL)) {
     $_SESSION['LOGIN_ERROR_MESSAGE'] = 'Il faut un email valide pour soumettre le formulaire.';
} else {
     foreach ($users as $user) {
         if (
             $user['email'] === $postData['email'] &&
             $user['password'] === $postData['password']
         ) {
             $_SESSION['LOGGED_USER'] = [
                 'email' => $user['email'],
                 'user_id' => $user['user_id'],
             ];
         }
     }

     if (!isset($_SESSION['LOGGED_USER'])) {
         $_SESSION['LOGIN_ERROR_MESSAGE'] = sprintf(
             'Les informations envoyées ne permettent pas de vous identifier : (%s/%s)',
             $postData['email'],
             strip_tags($postData['password'])
         );
     }
}

redirectToUrl('index.php');
}

Attendez, c'est quoi cette fonction  redirectToUrl('index.php');  ? Je ne l'ai jamais vue auparavant. À quoi sert-elle ?

La fonction  redirectToUrl('index.php');  que nous utilisons dans ce contexte sert à rediriger l'utilisateur vers une autre page. Dans ce cas précis, elle nous redirige vers la page d'accueil du site, qui est située à l'URL index.php. Lorsqu'un utilisateur soumet le formulaire de connexion avec des informations correctes, nous souhaitons le rediriger vers la page d'accueil.

3. Ajoutons la fonction  redirectToUrl()  dans functions.php.

D'abord, voyons le code de cette fonction :

<?php
function redirectToUrl(string $url): never
{
    header("Location: {$url}");
    exit();
}

En utilisant la fonction  header("Location: {$url}")  , on indique au navigateur web qu'il doit charger une nouvelle page dont l'adresse est spécifiée par $url.

Ensuite,  exit()  est utilisé pour arrêter immédiatement le reste du code PHP. Cela garantit que la redirection s'effectue sans problème, sans que d'autres instructions perturbent ce processus.

En somme, la fonction  redirectToUrl  est utile pour envoyer vers une autre page web, par exemple après une connexion réussie, une action sur un formulaire ou toute autre situation où l'on souhaite que l'utilisateur soit redirigé vers une nouvelle page.

Conservez les données grâce aux cookies

Travailler avec des cookies revient à peu près à la même chose qu'avec des sessions, à quelques petites différences près que nous allons voir.

Voici ce que nous allons faire pour découvrir les cookies :

  1. On va voir ce qu'est exactement un cookie (parce que si ça se trouve, il y en a qui croient en ce moment 
     même que je vais parler d'une recette de cuisine !).

  2. Ensuite, nous verrons comment écrire un cookie : c'est facile à faire, si on respecte quelques règles.

  3. Enfin, nous verrons comment récupérer le contenu d'un cookie : ce sera le plus simple.

Comprenez le fonctionnement d'un cookie

Un cookie, c'est un petit fichier que l'on enregistre sur l'ordinateur du visiteur.

Ce fichier contient du texte et permet de « retenir » des informations sur le visiteur.

Par exemple, vous inscrivez dans un cookie le pseudo du visiteur. Comme ça, la prochaine fois qu'il viendra sur votre site, vous pourrez lire son pseudo en allant regarder ce que son cookie contient.

Parfois, les cookies ont une mauvaise image.

On fait souvent l'erreur de penser que les cookies sont « dangereux ».

Non, ce ne sont pas des virus, juste de petits fichiers texte qui permettent de retenir des informations.

Au pire, un site marchand peut retenir que vous aimez les appareils photos numériques et vous afficher uniquement des pubs pour des appareils photos, mais c'est tout ; ces petites bêtes sont inoffensives pour votre ordinateur.

Chaque cookie stocke généralement une information à la fois.

Si vous voulez stocker le pseudonyme du visiteur et sa date de naissance, il est donc recommandé de créer deux cookies.

Où sont stockés les cookies sur mon disque dur ?

Cela dépend de votre navigateur web. Généralement, on ne touche pas directement à ces fichiers, mais on peut afficher à l'intérieur du navigateur la liste des cookies qui sont stockés.

On peut choisir de les supprimer à tout moment.

Si vous avez Mozilla Firefox, vous pouvez :

  1. Aller dans le menu "Paramètres" > "Vie privée et sécurité" > "Cookies et données de sites".

  2. Et cliquer sur "Gérer les données".

Vous obtenez la liste et la valeur de tous les cookies stockés, comme sur la figure suivante.

Les cookies sont classés par site web. Chaque site web peut écrire, comme vous le voyez, plusieurs cookies. Les cookies sont donc des informations temporaires que l'on stocke sur l'ordinateur des visiteurs. La taille est limitée à quelques kilo-octets : vous ne pouvez pas stocker beaucoup d'informations à la fois, mais c'est en général suffisant.

Écrivez un cookie

Comme une variable, un cookie a un nom et une valeur.

Par exemple, le cookie utilisateur aurait chez moi la valeur : LOGGED_USER 

Pour écrire un cookie, on utilise la fonction PHP setcookie  (qui signifie « Placer un cookie », en anglais).

On lui donne en général trois paramètres, dans l'ordre suivant :

  1. Le nom du cookie (exemple : LOGGED_USER ).

  2. La valeur du cookie (exemple :  utilisateur@exemple.com ).

  3. La date d'expiration du cookie, sous forme de "timestamp" (exemple :  1090521508 ).

Le paramètre correspondant à la date d'expiration du cookie mérite quelques explications. Il s'agit d'un timestamp, c'est-à-dire du nombre de secondes écoulées depuis le 1er janvier 1970. Le timestamp est une valeur qui augmente de 1 toutes les secondes. Pour obtenir le timestamp actuel, on fait appel à la fonction time() . Pour définir une date d'expiration du cookie, il faut ajouter au « moment actuel » le nombre de secondes au bout duquel il doit expirer.

Si vous voulez supprimer le cookie dans un an, il vous faudra donc écrire :time() + 365*24*3600 

Cela aura pour effet de supprimer votre cookie dans exactement un an.

Sécurisez un cookie avec les propriétés httpOnly et secure
Configurons les options httpOnly et secure sur le cookie.

Sans rentrer dans les détails, cela rendra votre cookie inaccessible en JavaScript sur tous les navigateurs qui supportent cette option (c'est le cas de tous les navigateurs récents). Cette option permet de réduire drastiquement les risques de faille XSS sur votre site, au cas où vous auriez oublié d'utiliser htmlspecialchars à un moment.

Voici comment créer un cookie de façon sécurisée :

<?php
// retenir l'email de la personne connectée pendant 1 an
setcookie(
    'LOGGED_USER',
    'utilisateur@exemple.com',
    [
        'expires' => time() + 365*24*3600,
        'secure' => true,
        'httponly' => true,
    ]
);

En écrivant les cookies de cette façon, vous diminuez le risque qu'un jour l'un de vos visiteurs puisse se faire voler le contenu d'un cookie à cause d'une faille XSS.

Ne placez donc JAMAIS le moindre code HTML avant d'utiliser setcookie !

La plupart des gens qui ont des problèmes avec setcookie ont fait cette erreur.

Affichez et récupérez un cookie

Avant de commencer à travailler sur une page, PHP lit les cookies du client pour récupérer toutes les informations qu'ils contiennent. Ces informations sont placées dans la superglobale  $_COOKIE sous forme d'un tableau (array), comme d'habitude.

De ce fait, si je veux ressortir l'e-mail du visiteur que j'avais inscrit dans un cookie, il suffit d'écrire :  $_COOKIE['LOGGED_USER'] 

Ce qui nous donne un code PHP tout bête pour afficher de nouveau le pseudo du visiteur :

Bonjour <?php echo $_COOKIE['LOGGED_USER']; ?> !

Comme vous le voyez encore une fois, le gros avantage, c'est que les superglobales sont accessibles partout.

À noter que si le cookie n'existe pas, la variable superglobale n'existe pas. Il faut donc faire un  isset  pour vérifier si le cookie existe ou non.

Les cookies viennent du visiteur. Comme toute information qui vient du visiteur, elle n'est pas sûre. N'importe quel visiteur peut créer des cookies et envoyer ainsi de fausses informations à votre site.

Modifiez un cookie existant
Vous vous demandez peut-être comment modifier un cookie déjà existant ? Il faut refaire appel à  setcookie en gardant le même nom de cookie, ce qui « écrasera » l'ancien.

Par exemple, si c'est Laurène Castor qui se connecte au site, je ferai :

<?php
setcookie(
    'LOGGED_USER',
    'laurene.castor@exemple.com',
    [
        'expires' => time() + 365*24*3600,
        'secure' => true,
        'httponly' => true,
    ]
);

Notez qu'alors le temps d'expiration du cookie est remis à zéro pour un an.

Exercez-vous

Et si nous ajoutions la fonctionnalité de déconnexion (logout) à votre site web !

Ah là là, encore un truc à ajouter ! Le chapitre était déjà super long… Et maintenant, la déconnexion ? J'ai vraiment besoin d'un coup de main !

Je comprends, ce chapitre a été assez dense, et l'ajout de la fonction de déconnexion peut sembler un peu intimidant. Mais ne vous inquiétez pas, pour rendre les choses plus simples, je vous suggère de diviser la tâche en étapes.

1. Créez un nouveau fichier PHP et nommez-le logout.php.

2. Dans ce fichier logout.php, programmez le code nécessaire pour déconnecter un utilisateur. Vous pouvez 
   utiliser les connaissances que vous avez acquises jusqu'à présent dans ce cours pour gérer la session de 
   l'utilisateur et supprimer ses données de connexion.

3.Ensuite, redirigez l'utilisateur vers la page d'accueil (index.php) une fois la déconnexion effectuée.

4.Dans le fichier header.php, ajoutez une condition pour afficher le lien vers logout.php uniquement si 
  l'utilisateur est connecté. Cela permettra aux utilisateurs connectés d'accéder facilement à la déconnexion.

5.Testez si la déconnexion fonctionne correctement sur le site web. Pour cela :

    1. Connectez-vous en utilisant l'email : mathieu.nebra@exemple.com et le mot de passe MiamMiam

    2. Une fois connecté, assurez-vous que le lien "Déconnexion" est visible.

    3. Cliquez sur le lien Déconnexion. Vérifiez que les informations de l'utilisateur ainsi que le lien 
       Déconnexion disparaissent.

À vous de jouer !

Vous pouvez retrouver le code modifié dans le dossier P3C5 du GitHub.

En résumé

- Les variables superglobales sont des variables automatiquement créées par PHP. Elles se présentent sous la 
  forme de tableaux (arrays) contenant différents types d'informations.

- Dans les chapitres précédents, nous avons découvert deux superglobales essentielles :  $_GET (qui contient 
  les données issues de l'URL) et $_POST (qui contient les données issues d'un formulaire).

- La superglobale $_SESSION permet de stocker des informations qui seront automatiquement transmises de page 
  en page pendant toute la durée de visite d'un internaute sur votre site. Il faut au préalable activer les 
  sessions en appelant la fonction  session_start() .

- La superglobale $_COOKIE représente le contenu de tous les cookies stockés par votre site sur l'ordinateur 
  du visiteur. Les cookies sont de petits fichiers que l'on peut écrire sur la machine du visiteur pour 
  retenir par exemple son nom. On crée un cookie avec la fonction  setcookie() .

C'est la fin de cette partie du cours ! Et devinez quoi ? C'est le moment de répondre au quiz avant de passer à la suite et fin du cours.

##############################################################################################################

