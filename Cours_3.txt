                                   Transmettez des données de page en page

Écoutez la requête de vos utilisateurs grâce aux URL

Grâce aux URL et à PHP, nous allons rendre le formulaire de contact dynamique en retournant une page de prise en compte de la demande à chaque personne qui soumettra le formulaire.

Je crois savoir ce qu'est une URL ; mais j'ai besoin d'en savoir plus pour lire ce chapitre ?

Un petit peu.

URL signifie Uniform Resource Locator. C'est en fait une adresse sur le Web.

Toutes les adresses que vous voyez en haut de votre navigateur, comme : https://www.openclassrooms.com sont des URL.

Lorsque vous faites une recherche sur Google pour trouver le site d'OpenClassrooms en tapant le mot "OpenClassrooms", la barre d'adresse contient une URL un peu longue qui ressemble à ceci :

http://www.google.fr/search?rlz=1C1GFR343&q=openclassrooms

Pourquoi ? Qu'est-ce que ça veut dire ?

Les informations après le point d'interrogation ? sont en réalité des données que l'on fait transiter d'une page à une autre. Nous allons découvrir dans ce chapitre comment cela fonctionne.

Envoyez des paramètres dans l'URL

Les URL permettent de transmettre des informations. Comment est-ce que ça fonctionne, exactement ? J'y viens !

Formez une URL pour envoyer des paramètres
Imaginons :

  - votre site s'appelle  monsite.com  ;

  - et possède une page PHP de contact :    contact.php  .

Pour accéder à la page de contact, vous devez aller à l'URL suivante :

http://www.monsite.com/contact.php

Jusque-là, rien de bien nouveau. Ce que je vous propose d'apprendre à faire, c'est d'envoyer des informations à la page  contact.php  .

Ces informations vont figurer à la fin de l'URL, comme ceci :

http://www.monsite.com/contact.php?nom=Dupont&prenom=Jean

Ce que vous voyez après le point d'interrogation, ce sont des paramètres que l'on envoie à la page PHP. Celle-ci peut récupérer ces informations dans des variables.

Voici comment on peut découper cette URL :

Le point d'interrogation sépare le nom de la page PHP des paramètres.

Les paramètres s'enchaînent selon la forme nom=valeur et sont séparés les uns des autres par le symbole   &  .

On peut écrire autant de paramètres que l'on veut ?

En théorie, oui.

Il suffit de les séparer par des & comme je l'ai fait. On peut donc voir une URL de la forme : 

page.php?param1=valeur1&param2=valeur2&param3=valeur3&param4=valeur4…

La seule limite est la longueur de l'URL. En général, il n'est pas conseillé de dépasser les 256 caractères, mais les navigateurs arrivent parfois à gérer des URL plus longues.

Créez un lien avec des paramètres

Maintenant que nous savons cela, nous pouvons créer des liens en HTML, qui transmettent des paramètres d'une page vers une autre.

Imaginons que vous ayez deux fichiers sur votre site :

  - index.php  (l'accueil) ;

  - bonjour.php .

Nous voulons faire un lien de index.php  à bonjour.php  pour transmettre des informations dans l'URL :

Pour cela, ouvrez index.php  (puisque c'est lui qui contiendra le lien) et insérez-y par exemple le code suivant :

<a href="bonjour.php?nom=Dupont&amp;prenom=Jean">Dis-moi bonjour !</a>
Comme vous le voyez, le &  dans le code a été remplacé par &amp;  dans le lien.

Ça n'a rien à voir avec PHP : simplement, en HTML, on demande à ce que les &  soient écrits &amp;  dans le code source.

Si vous ne le faites pas, le code ne passera pas la validation W3C.

Ce lien appelle la page bonjour.php et lui envoie deux paramètres :

  - nom : Dupont ;

  - prenom : Jean.

Créez un formulaire avec la méthode HTTP GET

Ce chapitre suppose que vous êtes capable de créer des formulaires à l'aide du langage HTML. Si vous ne vous sentez pas prêt, pas de panique : il suffit de lire le chapitre sur les formulaires du cours HTML & CSS. 

La deuxième solution pour faire passer des informations dans l'URL, c'est de proposer à l'utilisateur de soumettre un formulaire avec la méthode HTTP GET.

Nous pouvons faire cela avec une balise form qui a pour attribut method la valeur GET.

<form action="contact.php" method="GET">
    <!-- données à faire passer à l'aide d'inputs -->
    <input name="nom">
    <input name="prenom">
</form>

Les données soumises à l'aide du formulaire se retrouveront dans l'URL, comme pour un lien.

Comment faire dans la page contact.php ou dans bonjour.php pour récupérer ces informations ?

C'est ce que nous allons voir maintenant !

Récupérez les paramètres en PHP

Nous savons maintenant comment faire pour envoyer des paramètres vers une autre page.

Intéressons-nous maintenant à la page qui réceptionne les paramètres.

Pour notre besoin, nous avons un formulaire de contact – contact.php  – que nous allons soumettre sur une autre page, et qui affichera un message de bonne réception :submit_contact.php

Pour rappel, voici le formulaire de contact (simplifié) que nous avions dans le chapitre précédent :

<form action="submit_contact.php" method="GET">
    <div>
        <label for="email">Email</label>
        <input type="email" name="email">
    </div>
    <div>
        <label for="message">Votre message</label>
        <textarea placeholder="Exprimez vous" name="message"></textarea>
    </div>
    <button type="submit">Envoyer</button>
</form>

Par exemple, si l'utilisateur complète le formulaire de contact avec pour e-mail utilisateur@exemple.com et comme message "Bonjour".

Le formulaire va alors être converti en lien vers :submit_contact.php?email=utilisateur%40exemple.com&message=Bonjour 

Et ces informations pourront être récupérées par PHP dans le fichier submit_contact.php .

Lors de la soumission, une variable superglobale appelée $_GET  va contenir les données envoyées. Il s'agit d'un tableau associatif dont les clés correspondent aux noms des paramètres envoyés dans l'URL :

Nom                Valeur

$_GET['email']     utilisateur@exemple.com

$_GET['message']   Bonjour


On peut donc :

  - récupérer ces informations ;

  - les traiter ;

  - les afficher ;

  - bref, faire ce que l'on veut avec.

Pour l'exemple, créez un nouveau fichier PHP submit_contact.php et placez-y le code suivant :

<h1>Message bien reçu !</h1>
        
<div class="card">
    
    <div class="card-body">
        <h5 class="card-title">Rappel de vos informations</h5>
        <p class="card-text"><b>Email</b> : <?php echo $_GET['email']; ?></p>
        <p class="card-text"><b>Message</b> : <?php echo $_GET['message']; ?></p>
    </div>
</div>

Vous obtiendrez le résultat suivant :

Ne faites jamais confiance aux données reçues !

Il ne faut JAMAIS faire confiance aux variables qui transitent de page en page, comme $_GET  que nous étudions ici.

Oui je suis alarmiste, et oui je veux que vous ayez – un peu – peur !

Mais rassurez-vous : je vais vous expliquer tout ce qu'il faut savoir pour que ça se passe bien et que vous ne risquiez rien.

Tous les visiteurs peuvent trafiquer les URL
Si vous faites les tests des codes précédents chez vous, vous devriez tomber sur une URL de la forme :

http://localhost/submit_contact.php?email=utilisateur%40exemple.com&message=Bonjour

Mais si vous êtes un peu bricoleur, vous pouvez vous amuser à changer les paramètres directement dans la barre d'adresse, comme ici :

Essayez par exemple de modifier l'adresse pour :

http://localhost/submit_contact.php?email=utilisateur%40exemple.com&message=Mouahah

Comme vous le voyez, ça marche ! N'importe qui peut facilement modifier les URL et y mettre ce qu'il veut : il suffit simplement de changer l'URL dans la barre d'adresse de votre navigateur.

Et alors, quel est le problème ? C'est pas plus mal, si le visiteur veut adapter l'URL pour modifier le message ou l'e-mail qu'il nous a envoyé ?

Peut-être, mais cela montre une chose : on ne peut pas avoir confiance dans les données qu'on reçoit. N'importe quel visiteur peut les changer. 

Testez la présence d'un paramètre

Allons plus loin. Qu'est-ce qui empêche le visiteur de supprimer tous les paramètres de l'URL ? Par exemple, il peut très bien tenter d'accéder à :

http://localhost/submit_contact.php

Que va afficher la page submit_contact.php  ?

Faites le test ! Elle va afficher quelque chose comme :

Notice: Undefined index: email in submit_contact.php on line 15

OU

Warning: Undefined array key "email" in submit_contact.php on line 15

Que s'est-il passé ?

On a essayé d'afficher la valeur de $_GET['email']  et celle de  $_GET['message']  .

Mais comme on vient de les supprimer de l'URL, ces variables n'ont pas été créées, et donc elles n'existent pas ! PHP nous avertit qu'on essaie d'utiliser des variables qui n'existent pas, d'où les « Undefined index ».

Pour résoudre ce problème, on peut faire appel à une fonction un peu spéciale :  isset()  .

La fonction isset() teste si une variable existe.

Nous allons nous en servir pour afficher un message spécifique, dans le cas où le nom ou le prénom serait absent.

<?php
$getData = $_GET;

if (!isset($getData['email']) || !isset($getData['message']))
{
    echo('Il faut un email et un message pour soumettre le formulaire.');
    // Arrête l'exécution de ce fichier par PHP
    return;
}
?>
Que fait ce code ?

Il teste si les variables $getData['email']  et $getData['message']  existent.

  1. Si elles existent, on affiche la confirmation de prise en compte du message.

  2. S'il nous manque une des variables (ou les deux), on affiche un message d'erreur : "Il faut un e-mail et 
     un message pour soumettre le formulaire", et on arrête l'exécution de la page.

Essayez maintenant d'accéder à la page submit_contact.php sans les paramètres.

Vous allez voir qu'on gère bien le cas où le visiteur aurait retiré les paramètres de l'URL :

Est-ce que c'est vraiment la peine de gérer ce cas ? C'est vrai quoi, moi je ne m'amuse jamais à modifier mes URL, et mes visiteurs non plus, je pense !

Oui, oui, trois fois oui : il faut que vous pensiez à gérer le cas où des paramètres que vous attendiez viendraient à manquer.

Vous vous souvenez de ce que je vous ai dit ? Il ne faut jamais faire confiance à l'utilisateur.

Tôt ou tard vous tomberez sur un utilisateur mal intentionné qui essaiera de trafiquer l'URL pour mettre n'importe quoi dans les paramètres. Il faut que votre site soit prêt à gérer le cas.

Dans notre exemple, si on ne gérait pas le cas, ça ne faisait rien de bien grave (ça affichait juste des messages d'erreur). Mais lorsque votre site web deviendra plus complexe, cela pourrait avoir des conséquences plus ennuyeuses.

Contrôlez la valeur des paramètres

Une fois les valeurs soumises et correctement récupérées, il faut vérifier qu'elles correspondent à ce qui est attendu !

Imaginez par exemple que l'utilisateur se soit trompé et que l'e-mail envoyé ne soit pas valide : vous ne pourrez donc pas le recontacter pour répondre à son besoin !

Il va donc falloir :

  - contrôler si l'e-mail passé est bien valide, à l'aide de la fonction filter_var ;

  - et vérifier que le message n'est pas vide, à l'aide de la fonction empty.

Voici donc le code final sécurisé, qui prévoit tous les cas pour éviter d'être pris au dépourvu par un utilisateur mal intentionné :

<?php
$getData = $_GET;

if (
    !isset($getData['email'])
    || !filter_var($getData['email'], FILTER_VALIDATE_EMAIL)
    || empty($getData['message'])
    || trim($getData['message']) === ''
) {
    echo('Il faut un email et un message valides pour soumettre le formulaire.');
    return;
}

Cela fait beaucoup de conditions pour quelque chose qui était à la base assez simple, mais c'était nécessaire. Vous devrez toujours faire très attention et prévoir tous les cas les plus tordus, comme nous venons de le faire :

  - vérifier que tous les paramètres que vous attendiez sont bien là ;

  - vérifier qu'ils contiennent des valeurs correctes, comprises dans des intervalles raisonnables.

Si vous gardez cela en tête, vous n'aurez pas de problèmes !

Nous n'avons pas détaillé le fonctionnement des fonctions filter_var ,  trim  et  empty .

N'hésitez pas à consulter tous les exemples de la documentation PHP pour bien comprendre son fonctionnement.

Exercez-vous

C'est à vous maintenant de valider les données du formulaire de contact (e-mail et message) dans notre projet fil rouge !

Vous pouvez retrouver le code modifié dans le dossier P3C1 du GitHub.

En résumé

- Une URL représente l'adresse d'une page web, commençant généralement par http://   .

- Lorsqu'on fait un lien vers une page, il est possible d'ajouter des paramètres sous la forme 
  bonjour.php?nom=Dupont&prenom=Jean qui seront transmis à la page.

- La page de réception recevra ces paramètres dans un tableau (array) nommé  $_GET  .

- Cette technique est très pratique pour transmettre des valeurs à une page, mais il faut prendre garde au 
  fait que le visiteur peut les modifier très facilement.

- La fonction isset() permet de vérifier si une variable est définie ou non.

- D'autres fonctions comme filter_var() ,  trim()  ou empty() peuvent être utilisées pour la validation des 
  champs.

Dans le prochain chapitre, nous allons voir comment administrer des formulaires de manière sécurisée. C'est parti !

##############################################################################################################

Administrez des formulaires de façon sécurisée

Les formulaires constituent le principal moyen pour vos visiteurs d'entrer des informations sur votre site. Dans le chapitre précédent, nous avions d'ailleurs abordé un premier formulaire de contact assez basique pour envoyer une URL avec des paramètres.

Dans ce chapitre, vous allez apprendre à faire des formulaires plus sécurisés.

Ce chapitre est particulièrement important ; nous réutiliserons ce que nous avons appris ici dans toute la suite du cours. Soyez attentif !

Ce chapitre suppose que vous êtes capable de créer des formulaires à l'aide du langage HTML. Si vous ne vous sentez pas prêt, pas de panique : il suffit de lire le chapitre sur les formulaires du cours HTML & CSS.

Rappelez-vous : la base du formulaire

En HTML, pour insérer un formulaire, on se sert de la balise  <form>  .

On l'utilise de la manière suivante :

<!-- index.php -->
<form method="post" action="submit_form.php">
 
<p>
    On insèrera ici les éléments de notre formulaire.
</p>
 
</form>
Il y a deux attributs très importants à connaître pour la balise <form>  :

  1. La méthode :  method  .

  2. Et la cible :  action  . 

Il est impératif que vous compreniez à quoi ils servent.

Privilégiez la méthode post pour envoyer les données du formulaire

Il faut savoir qu'il existe plusieurs moyens d'envoyer les données du formulaire (plusieurs « méthodes »).

Vous pouvez en employer deux :

  1. get : les données transiteront par l'URL, comme on l'a appris précédemment. On pourra les récupérer grâce 
     au tableau (array) $_GET  . Cette méthode est assez peu utilisée car on ne peut pas envoyer beaucoup 
     d'informations dans l'URL (je vous disais dans le chapitre précédent qu'il était préférable de ne pas 
     dépasser 256 caractères).

  2. post : les données ne transiteront pas par l'URL, l'utilisateur ne les verra donc pas passer dans la 
     barre d'adresse. Cette méthode permet d'envoyer autant de données que l'on veut, ce qui fait qu'on la 
     privilégie le plus souvent. Néanmoins, les données ne sont pas plus sécurisées qu'avec la méthode GET  , 
     et il faudra toujours vérifier si tous les paramètres sont bien présents et valides, comme on l'a fait 
     dans le chapitre précédent. On ne doit pas plus faire confiance aux formulaires qu'aux URL.

La bonne pratique consiste généralement à privilégier la méthode post pour les formulaires.

Choisissez la page appelée par le formulaire en définissant la cible

L'attribut action  sert à définir la page appelée par le formulaire. C'est cette page qui recevra les données du formulaire, et qui sera chargée de les traiter.

Selon la méthode utilisée, ce ne sera pas la même variable spéciale qui aura accès aux données :

  - Si la méthode est  GET  (comme dans le chapitre précédent), alors c'est la supervariable  $_GET qui aura 
    les données ;

  - Si la méthode est  POST  (bonne pratique), alors c'est la supervariable  $_POST  qui recevra les données.

Retenez donc bien que vous travaillez normalement sur deux pages différentes :

  1. La page qui contient le formulaire ( form.php  dans notre exemple) ;

  2. Et celle qui reçoit les données du formulaire pour les traiter ( submit_form.php  ).

Ajoutez un ou plusieurs champs input avec un attribut name

La variable  $_GET  sera complétée avec la valeur de l'attribut  name  en tant que clé, et aura pour valeur ce qui aura été soumis par l'utilisateur :

<input type="text" name="nom" value="Mateo21" />

<?php

// Après soumission du formulaire
echo $_GET['nom']; // "Mateo21"

// OU

echo $_POST['nom']; // "Mateo21"

Il y aura autant de clés dans le tableau $_GET que de champs avec un attribut name dans le formulaire soumis.

Faites attention avec les champs cachés

Les champs cachés constituent un type de champ à part.

En quoi ça consiste ?

C'est un code dans votre formulaire qui n'apparaîtra pas aux yeux du visiteur, mais qui va quand même créer une variable avec une valeur. On peut s'en servir pour transmettre des informations fixes.

Je m'explique : supposons que vous ayez besoin de « retenir » que le pseudo du visiteur est « Mateo21 ». Vous allez taper ce code :

<input type="hidden" name="pseudo" value="Mateo21" />

À l'écran, sur la page web on ne verra rien. Mais dans la page cible, une variable $_POST['pseudo'] sera créée, et elle aura la valeur « Mateo21 » !

C'est apparemment inutile, mais vous verrez que vous en aurez parfois besoin.

On croit par erreur que, parce que ces champs sont cachés, le visiteur ne peut pas les voir. C'est faux ! En effet, n'importe quel visiteur peut afficher le code source de la page pour voir et modifier les champs cachés en lisant le code HTML.

Ne faites jamais confiance aux données reçues : la faille XSS

Vous vous souvenez des mises en garde que j'avais faites dans le chapitre précédent ? Elles ne concernaient pas que les paramètres qui transitent par l'URL : tout cela vaut aussi pour les formulaires !

Je vois comment on peut modifier l'URL, mais comment peut faire un visiteur pour modifier le formulaire de mon site et trafiquer les données ?

J'y viens…

La faille XSS : attention au code HTML que vous recevez !

La sécurité des applications web est un sujet très important à maîtriser lors de votre apprentissage. Si vous souhaitez en savoir plus sur le sujet, consultez le cours "Sécurisez vos applications web avec l'OWASP".

La faille XSS (pour cross-site scripting) est vieille comme le monde (euh, comme le Web) et on la trouve encore sur de nombreux sites web, même professionnels ! C'est une technique qui consiste à injecter du code HTML contenant du JavaScript dans vos pages, pour le faire exécuter à vos visiteurs.

Reprenons la page de récapitulatif qui affiche l'e-mail et le message qu'on a soumis dans le chapitre précédent :

<h5>Rappel de vos informations</h5>
<p><b>Email</b> : <?php echo $_POST['email']; ?></p>
<p><b>Message</b> : <?php echo $_POST['message']; ?></p>

Si le visiteur décide d'écrire du code HTML dans la zone de message, cela fonctionnera très bien !

Par exemple, imaginons qu'il écrive dans le champ « Votre message » le code :<strong>Badaboum</strong>

Le code source HTML qui sera généré par PHP sera le suivant :

<p><b>Message</b> : <strong>Badaboum</strong></p>

Et alors ? S'il veut mettre son message en gras, c'est son problème, non ?

Outre le fait qu'il peut insérer n'importe quel code HTML (et rendre votre page invalide), ce qui n'est pas le plus grave, il peut aussi ouvrir des balises de type <script> pour faire exécuter du code JavaScript au visiteur qui visualisera la page !

<p><b>Message</b> : <script>alert('Badaboum')</script></p>

Tous les visiteurs qui arriveront sur cette page verront une boîte de dialogue JavaScript s'afficher. Plutôt gênant. Voyez la figure suivante.

Sécurisez votre code en bloquant l'exécution de code JavaScript

Pour ignorer le code HTML, il suffit d'utiliser la fonction  htmlspecialchars  .

On dira dans ce cas qu'on "échappe" le code HTML, c'est-à-dire que la fonction JavaScript alert() n'en tiendra pas compte.

Elle va transformer les chevrons des balises HTML  <  et  >  en &lt;  et &gt;  respectivement.

Cela provoquera l'affichage de la balise plutôt que son exécution.

<p><b>Message</b> : <?php echo htmlspecialchars($_POST['message']); ?></p>

Le code HTML qui en résultera sera propre et protégé, car les balises HTML insérées par le visiteur auront été échappées :

<p><b>Message</b> : &lt;strong&gt;Badaboum&lt;/strong&gt; ?></p>

Il faut penser à utiliser cette fonction sur tous les textes envoyés par l'utilisateur qui sont susceptibles d'être affichés sur une page web.

Bref, tout ce qui est affiché et qui vient, à la base, d'un visiteur, vous devez penser à le protéger avec  htmlspecialchars  .

Si vous préférez retirer les balises HTML que le visiteur a tenté d'envoyer plutôt que de les afficher, utilisez la fonction  strip_tags  .

Voici donc une nouvelle version du code de réception du formulaire (avec method="POST"  ) sécurisée, qui prévoit tous les cas pour éviter d'être pris au dépourvu par un utilisateur mal intentionné :

<?php
/**
* On ne traite pas les super globales provenant de l'utilisateur directement,
* ces données doivent être testées et vérifiées.
*/
$postData = $_POST;

if (
    !isset($postData['email'])
    || !filter_var($postData['email'], FILTER_VALIDATE_EMAIL)
    || empty($postData['message'])
    || trim($postData['message']) === ''
) {
    echo('Il faut un email et un message valides pour soumettre le formulaire.');
    return;
}
?>

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site de Recettes - Contact reçu</title>
    <link
href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
rel="stylesheet"
>
</head>

<body>
    <div class="container">
        <?php require_once(__DIR__ . '/header.php'); ?>
        <h1>Message bien reçu !</h1>
        <div class="card">
        <div class="card-body">
            <h5 class="card-title">Rappel de vos informations</h5>
            <p class="card-text"><b>Email</b> : <?php echo($postData['email']); ?></p>
            <p class="card-text"><b>Message</b> : <?php echo(strip_tags($postData['message'])); ?></p>
        </div>
    </div>
</body>
</html>

Exercez-vous

Il est temps de refaire les modifications par vous-même et d'utiliser  POST  à la place de  GET .

Vous pouvez retrouver le code modifié dans le dossier P3C2 du GitHub.

En résumé

- Les formulaires sont le moyen le plus pratique pour le visiteur de transmettre des informations à votre 
  site. PHP est capable de récupérer les données saisies par vos visiteurs et de les traiter.

- Les données envoyées via un formulaire se retrouvent dans un tableau (array)  $_POST  .

- De la même manière que pour les URL, il ne faut pas donner sa confiance absolue aux données que vous envoie 
  l'utilisateur. Traitez les données reçues avec vigilance.

- Que ce soit pour des données issues de l'URL ( $_GET  ) ou d'un formulaire ( $_POST  ), il faut s'assurer 
  qu'aucun texte qui vous est envoyé ne contient du HTML si celui-ci est destiné à être affiché sur une page. 
  Sinon, vous ouvrez une faille appelée XSS qui peut être néfaste pour la sécurité de votre site.

- Pour éviter la faille XSS, il suffit d'appliquer la fonction htmlspecialchars  ou  strip_tags sur tous les 
  textes envoyés par vos visiteurs que vous afficherez.

Dans le prochain chapitre, nous allons voir comment permettre aux utilisateurs de votre site de partager et d'envoyer des fichiers. On y va !

##############################################################################################################

Activez le partage de fichiers

Imaginez qu'une personne essaie de vous contacter car elle est victime d'un bug d'utilisation sur votre site : elle souhaiterait peut-être vous partager une capture d'écran, ce qui faciliterait beaucoup votre travail de déboggage.

Pour cela, vous allez devoir proposer la soumission de fichiers dans votre formulaire de contact !

Vous aviez découvert les superglobales  $_GET  et  $_POST  dans les chapitres précédents, c'est maintenant au tour de la supervariable  $_FILES  de faire son entrée dans votre projet !

Donnez la possibilité d'envoyer des fichiers

Vous saviez qu'on pouvait aussi envoyer des fichiers grâce aux formulaires ?

Là encore, ça se passe en deux temps.

  1. Le visiteur arrive sur votre formulaire et le remplit (en indiquant le fichier à envoyer). Une simple 
     page HTML suffit pour créer le formulaire.

  2. PHP réceptionne les données du formulaire et, s'il y a des fichiers dedans, il les « enregistre » dans un 
     des dossiers du serveur.

Attention : l'envoi du fichier peut être un peu long si celui-ci est gros. Il faudra dire au visiteur de ne pas s'impatienter pendant l'envoi.

Vous allez devoir adapter votre formulaire de contact pour autoriser l'envoi et la soumission.

Paramétrez le formulaire d'envoi de fichier
Dès l'instant où votre formulaire propose aux visiteurs d'envoyer un fichier, il faut ajouter l'attribut enctype="multipart/form-data" à la balise  <form>  .

<form action="submit_contact.php" method="POST" enctype="multipart/form-data">
    <!-- champs de formulaire -->
</form>

Grâce à enctype , le navigateur du visiteur sait qu'il s'apprête à envoyer des fichiers.

Maintenant que c'est fait, nous pouvons ajouter à l'intérieur du formulaire une balise permettant d'envoyer un fichier.

C'est une balise très simple de type   <input type="file" />  .

Il faut donner un nom à ce champ de formulaire (grâce à l'attribut name ) pour que PHP puisse reconnaître le champ par la suite.

<form action="submit_contact.php" method="POST" enctype="multipart/form-data">
    <!-- Ajout des champs email et message -->
    [...]
    <!-- Ajout champ d'upload ! -->
    <div class="mb-3">
        <label for="screenshot" class="form-label">Votre capture d'écran</label>
        <input type="file" class="form-control" id="screenshot" name="screenshot" />
    </div>
    <!-- Fin ajout du champ -->
    <button type="submit" class="btn btn-primary">Envoyer</button>
</form>

Voilà, c'est suffisant.

Traitez l'envoi en PHP

C'est maintenant que ça devient important. Il faut que l'on ajoute du code dans la page submit_contact.php pour traiter l'envoi du fichier.

« Traiter l'envoi du fichier » ? C'est-à-dire ? Si le fichier a été envoyé sur le serveur, c'est bon, non ? Qu'est-ce que PHP aurait besoin de faire ?

En fait, au moment où la page PHP s'exécute, le fichier a été envoyé sur le serveur mais il est stocké dans un dossier temporaire.

C'est à vous de décider si vous acceptez définitivement le fichier ou non.

Vous pouvez par exemple vérifier si le fichier a la bonne extension (si vous demandez une image et qu'on vous envoie un « .txt », vous devrez refuser le fichier).

Si le fichier est bon, vous l'accepterez grâce à la fonction move_uploaded_file et ce, d'une manière définitive.

Mais comment je sais si « le fichier est bon » ?

Pour chaque fichier envoyé, une variable $_FILES['nom_du_champ'] est créée.

Dans notre cas, la variable s'appellera $_FILES['screenshot'] 

Cette variable est un tableau qui contient plusieurs informations sur le fichier :


Variable                               Signification

$_FILES['screenshot']['name']          Contient le nom du fichier envoyé par le visiteur.

$_FILES['screenshot']['type']          Indique le type du fichier envoyé. Si c'est une image gif par exemple, 
                                       le type sera image/gif

$_FILES['screenshot']['size']          Indique la taille du fichier envoyé.

                                       Attention : cette taille est en octets. Il faut environ 1 000 octets 
                                       pour faire 1 Ko, et 1 000 000 d'octets pour faire 1 Mo.
                                       La taille de l'envoi est limitée par PHP. Par défaut, impossible 
                                       d'uploader des fichiers de plus de 8 Mo.

$_FILES['screenshot']['tmp_name']      Juste après l'envoi, le fichier est placé dans un répertoire temporaire 
                                       sur le serveur en attendant que votre script PHP décide si oui ou non 
                                       il accepte de le stocker pour de bon. Cette variable contient 
                                       l'emplacement temporaire du fichier (c'est PHP qui gère ça).

$_FILES['screenshot']['error']         Contient un code d'erreur permettant de savoir si l'envoi s'est bien 
                                       effectué ou s'il y a eu un problème et si oui, lequel. La variable vaut 
                                       0 s'il n'y a pas eu d'erreur.



Si vous avez mis un second champ d'envoi de fichier dans votre formulaire, il y aura une seconde variable $_FILES['nom_de_votre_autre_champ'] découpée de la même manière que le tableau qu'on vient de voir ici.

$_FILES['nom_de_votre_autre_champ']['size'] contiendra donc la taille du second fichier, et ainsi de suite.

Je vous propose de faire les vérifications suivantes pour décider si l'on accepte le fichier ou non.

  1. Vérifier tout d'abord si le visiteur a bien envoyé un fichier, en testant la variable 
     $_FILES['screenshot'] avec isset() et s'il n'y a pas eu d'erreur d'envoi, grâce à 
     $_FILES['screenshot']['error'] .

  2. Vérifier si la taille du fichier ne dépasse pas 1 Mo par exemple (environ 1 000 000 d'octets), grâce à 
     $_FILES['screenshot']['size']  .

  3. Vérifier si l'extension du fichier est autorisée (il faut interdire à tout prix que les gens puissent 
     envoyer des fichiers PHP, sinon ils pourraient exécuter des scripts sur votre serveur). Dans notre cas, 
     nous autoriserons seulement les images (fichiers .png, .jpg, .jpeg et .gif).
     Nous analyserons pour cela la variable $_FILES['screenshot']['name'] .

Nous allons donc faire une série de tests dans notre page submit_contact.php .

1/ Testez si le fichier a bien été envoyé
On commence par vérifier qu'un fichier a été envoyé.

Pour cela, on va tester si la variable $_FILES['screenshot']  existe avec  isset()  .

On vérifie dans le même temps s'il n'y a pas d'erreur d'envoi.

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas d'erreur
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] == 0)
{
 
}
?>

2/ Vérifiez la taille du fichier
On veut interdire que le fichier dépasse 1 Mo, soit environ 1 000 000 d'octets (j'arrondis pour simplifier). On doit donc tester $_FILES['screenshot']['size'] :

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }
}

3/ Vérifiez l'extension du fichier
On peut récupérer l'extension du fichier dans une variable grâce à ce code :

<?php
$fileInfo = pathinfo($_FILES['screenshot']['name']);
$extension = $fileInfo['extension'];
?>

La fonction pathinfo renvoie un tableau (array) contenant entre autres l'extension du fichier dans  $fileInfo['extension']  .

On stocke ça dans une variable  $extension  .

Une fois l'extension récupérée, on peut la comparer à un tableau d'extensions autorisées, et vérifier si l'extension récupérée fait bien partie des extensions autorisées à l'aide de la fonction in_array() .

Ouf ! On obtient ce code :

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }
    
    // Testons, si l'extension n'est pas autorisée
    $fileInfo = pathinfo($_FILES['screenshot']['name']);
    $extension = $fileInfo['extension'];
    $allowedExtensions = ['jpg', 'jpeg', 'gif', 'png'];
    if (!in_array($extension, $allowedExtensions)) {
        echo "L'envoi n'a pas pu être effectué, l'extension {$extension} n'est pas autorisée";
        return;
    }
}

4/ Vérifiez si le dossier pour stocker les images existe
Je propose de placer le fichier dans un sous-dossier « uploads ». Pour vérifier si notre dossier uploads existe, nous allons utiliser la fonction  is_dir()  . Il nous suffit de lui fournir le chemin du dossier que nous souhaitons tester. La fonction renvoie true si le dossier existe et false dans le cas contraire.

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }

    // Testons, si l'extension n'est pas autorisée
    $fileInfo = pathinfo($_FILES['screenshot']['name']);
    $extension = $fileInfo['extension'];
    $allowedExtensions = ['jpg', 'jpeg', 'gif', 'png'];
    if (!in_array($extension, $allowedExtensions)) {
        echo "L'envoi n'a pas pu être effectué, l'extension {$extension} n'est pas autorisée";
        return;
    }

    // Testons, si le dossier uploads est manquant
    $path = __DIR__ . '/uploads/';
    if (!is_dir($path)) {
        echo "L'envoi n'a pas pu être effectué, le dossier uploads est manquant";
        return;
    }
}

5/ Validez l'upload du fichier
Si tout est bon, on accepte le fichier en appelant   move_uploaded_file()  .

Cette fonction prend deux paramètres :

  1. Le nom temporaire du fichier (on l'a avec  $_FILES['screenshot']['tmp_name']  ).

  2. Le chemin qui est le nom sous lequel sera stocké le fichier de façon définitive. On peut utiliser le nom 
     d'origine du fichier  $_FILES['screenshot']['name']  ou générer un nom au hasard.

On gardera le même nom de fichier que celui d'origine.

Comme  $_FILES['screenshot']['name']  contient le chemin entier vers le fichier d'origine (  C:\dossier\fichier.png  , par exemple), il nous faudra extraire le nom du fichier.

On peut utiliser pour cela la fonction  basename  qui renverra juste « fichier.png ».

<?php
// Testons si le fichier a bien été envoyé et s'il n'y a pas des erreurs
if (isset($_FILES['screenshot']) && $_FILES['screenshot']['error'] === 0) {
    // Testons, si le fichier est trop volumineux
    if ($_FILES['screenshot']['size'] > 1000000) {
        echo "L'envoi n'a pas pu être effectué, erreur ou image trop volumineuse";
        return;
    }
    // Testons, si l'extension n'est pas autorisée
    $fileInfo = pathinfo($_FILES['screenshot']['name']);
    $extension = $fileInfo['extension'];
    $allowedExtensions = ['jpg', 'jpeg', 'gif', 'png'];
    if (!in_array($extension, $allowedExtensions)) {
        echo "L'envoi n'a pas pu être effectué, l'extension {$extension} n'est pas autorisée";
        return;
    }
    // Testons, si le dossier uploads est manquant
    $path = __DIR__ . '/uploads/';
    if (!is_dir($path)) {
        echo "L'envoi n'a pas pu être effectué, le dossier uploads est manquant";
        return;
    }
    // On peut valider le fichier et le stocker définitivement
    move_uploaded_file($_FILES['screenshot']['tmp_name'], $path . basename($_FILES['screenshot']['name']));
}

Lorsque vous mettrez le script sur Internet à l'aide d'un logiciel FTP, vérifiez que le dossier « Uploads » sur le serveur existe, et qu'il a les droits d'écriture. Pour ce faire, sous FileZilla par exemple, faites un clic droit sur le dossier et choisissez « Attributs du fichier ».
Cela vous permettra d'éditer les droits du dossier (on parle de CHMOD). Mettez les droits à 733, ainsi PHP pourra placer les fichiers téléversés dans ce dossier.

Ce script est un début, mais en pratique il vous faudra sûrement encore l'améliorer.

Par exemple, si le nom du fichier contient des espaces ou des accents, ça posera un problème une fois envoyé sur le Web. D'autre part, si quelqu'un envoie un fichier qui a le même nom que celui d'une autre personne, l'ancien sera écrasé !

La solution consiste en général à « choisir » nous-mêmes le nom du fichier stocké sur le serveur, plutôt que de nous servir du nom d'origine. Vous pouvez faire un compteur qui s'incrémente : 1.png, 2.png, 3.jpg, etc.

Soyez toujours très vigilant sur la sécurité ; vous devez éviter que quelqu'un puisse envoyer des fichiers PHP sur votre serveur.

Exercez-vous

Il nous reste à apporter une modification supplémentaire pour que notre affichage prenne en compte le chargement du fichier.

Étant donné que le champ d'image n'est pas obligatoire dans notre formulaire, nous afficherons le message suivant "L'envoi a bien été effectué !" uniquement si une image a été téléchargée.

Vous pouvez retrouver le code modifié dans le dossier P3C3 du GitHub.

En résumé

- Les formulaires permettent d'envoyer des fichiers. On retrouve les informations sur les fichiers envoyés 
  dans un array $_FILES . Leur traitement est cependant plus complexe.

- Il faudra toujours contrôler les fichiers reçus : leur existence et leur taille qui est soumise à limitation 
  par la configuration de PHP.

- Il faudra vérifier leur extension (à l'aide de la fonction pathinfo) et surtout refuser tout fichier PHP qui 
  pourrait par la suite s'exécuter sur votre serveur.

- À l'aide de la fonction move_uploaded_file, vous pouvez conserver le fichier téléversé sur votre serveur, 
  mais vérifiez bien que vous avez les droits d'écrire des fichiers d'abord.

Dans le prochain chapitre, nous allons voir comment implémenter un système de connexion pour vos utilisateurs. 

##############################################################################################################

