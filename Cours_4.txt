                                 Stockez des informations dans une base de donn√©es

Travaillez avec une base de donn√©es

Pour l'instant, vous avez d√©couvert le fonctionnement du langage PHP, mais vous ne vous sentez probablement pas encore capable de cr√©er de vrais sites web avec ce que vous avez appris. C'est parfaitement normal, car il vous manque un √©l√©ment crucial : la base de donn√©es.

Une base de donn√©es permet d'enregistrer des donn√©es de fa√ßon organis√©e et hi√©rarchis√©e.

Certes, vous connaissez les variables, mais celles-ci restent en m√©moire seulement le temps de la g√©n√©ration de la page. Vous pourriez aussi √©crire vos donn√©es dans des fichiers, mais cela devient vite tr√®s compliqu√©, d√®s que vous avez beaucoup de donn√©es √† enregistrer.

Or, il va bien falloir stocker quelque part la liste de vos membres, les recettes, les commentaires sous les recettes‚Ä¶ Les bases de donn√©es constituent le meilleur moyen de faire cela de fa√ßon simple et propre. Nous allons les √©tudier durant toute cette partie du cours !

D√©couvrez langage SQL et les bases de donn√©es

La base de donn√©es (BDD) est un syst√®me qui enregistre des informations.

Un peu comme un fichier texte ?

Non, pas vraiment. Ce qui est tr√®s important ici, c'est que ces informations sont toujours organis√©es. Et c'est √ßa qui fait que la BDD est si pratique : c'est un moyen simple de ranger des informations.

Et si je pr√©f√®re rester d√©sordonn√© ? Si je n'ai pas envie de classer mes informations ?
Est-on oblig√© de classer chaque information qu'on enregistre ?

C'est un peu ce que je me disais au d√©but‚Ä¶ Classer certaines choses, d'accord, mais il me semblait que je n'en aurais besoin que tr√®s rarement.

Grave erreur ! Vous allez le voir : 99 % du temps, on range ses informations dans une base de donn√©es. Pour le reste, on peut les enregistrer dans un fichier comme on a appris √† le faire‚Ä¶ mais quand on a go√ªt√© aux bases de donn√©es, on peut difficilement s'en passer ensuite !

Imaginez par exemple une armoire, dans laquelle chaque dossier est √† sa place.

Quand tout est √† sa place, il est beaucoup plus facile de retrouver un objet, n'est-ce pas ? Eh bien l√†, c'est pareil : en classant les informations que vous collectez (concernant vos visiteurs, par exemple), il vous sera tr√®s facile de r√©cup√©rer plus tard ce que vous cherchez.

Nous allons utiliser le Syst√®me de Gestion de Base de Donn√©es (SGBD) avec MySQL, mais sachez que l'essentiel de ce que vous allez apprendre fonctionnera de la m√™me mani√®re avec un autre SGBD. Cette partie est construite afin que vous ayez le moins de choses possible √† apprendre de nouveau si vous choisissez de changer de SGBD.

Donnez les ordres au SGBD en langage SQL

Vous allez devoir communiquer avec le SGBD pour lui donner l'ordre de r√©cup√©rer ou d'enregistrer des donn√©es. Pour lui "parler", on utilise le langage SQL.

La bonne nouvelle, c'est que le langage SQL est un standard, c'est-√†-dire que quel que soit le SGBD que vous utilisez, vous vous servirez du langage SQL. La mauvaise, c'est qu'il y a en fait quelques petites variantes d'un SGBD √† l'autre, mais cela concerne g√©n√©ralement les commandes les plus avanc√©es.

Comme vous vous en doutez, il va falloir apprendre le langage SQL pour travailler avec les bases de donn√©es. Ce langage n'a rien √† voir avec le PHP, mais nous allons imp√©rativement en avoir besoin.

Voici un exemple de commande en langage SQL, pour vous donner une id√©e :

SELECT id, auteur, message, datemsg FROM livreor ORDER BY datemsg DESC

Le principal objectif de cette partie du cours sera d'apprendre les instructions n√©cessaires √† √©crire en PHP pour effectuer des requ√™tes en base de donn√©es, et les bases du langage SQL.

MySQL et le SQL sont des comp√©tences tr√®s pr√©cieuses et utiles tout au long de votre carri√®re en d√©veloppement web, et si vous souhaitez progresser sur le sujet, n'h√©sitez pas √† suivre le cours intitul√© "Impl√©mentez vos bases de donn√©es relationnelles avec SQL" en compl√©ment de ce cours.

Comprenez comment PHP fait la jonction entre vous et MySQL
Pour compliquer un petit peu l'affaire (sinon, ce n'est pas rigolo), on ne va pas pouvoir parler √† MySQL directement. Eh non, seul PHP peut le faire !

C'est donc PHP qui va faire l'interm√©diaire entre vous et MySQL. On devra demander √† PHP : "Va dire √† MySQL de faire ceci".

Je crois qu'un petit sch√©ma ne serait pas du luxe :

Voici ce qui peut se passer lorsque le serveur a re√ßu une demande d'un client qui veut poster un message :

  1. Le serveur utilise toujours PHP, il lui fait donc passer le message.

  2. PHP effectue les actions demand√©es et se rend compte qu'il a besoin de MySQL. En effet, le code PHP 
     contient √† un endroit "Va demander √† MySQL d'enregistrer ce message". Il fait donc passer le travail √† 
     MySQL.

  3. MySQL fait le travail que PHP lui a soumis et lui r√©pond "OK, c'est bon !".

  4. PHP renvoie au serveur que MySQL a bien fait ce qui lui √©tait demand√©.

Maintenant que nous avons fait les pr√©sentations, il va falloir d√©couvrir comment est organis√©e une base de donn√©es. Bien en comprendre l'organisation est en effet absolument indispensable.

Structurez votre base de donn√©es

Avec les bases de donn√©es, il faut utiliser un vocabulaire pr√©cis. Heureusement, vous ne devriez pas avoir trop de mal √† vous en souvenir, vu qu'on va se servir d'une image : celle d'une armoire. √âcoutez-moi attentivement et n'h√©sitez pas √† lire lentement, plusieurs fois si c'est n√©cessaire.

Je vous demande d'imaginer ce qui suit.

  - L'armoire est appel√©e "la base" dans le langage SQL. C'est le gros meuble dans lequel les secr√©taires ont 
    l'habitude de classer les informations.

  - Dans une armoire, il y a plusieurs tiroirs. Un tiroir, en SQL, c'est ce qu'on appelle "une table". Chaque 
    tiroir contient des donn√©es diff√©rentes. Par exemple, on peut imaginer un tiroir qui contient les 
    pseudonymes et informations sur vos visiteurs, un autre qui contient les messages post√©s sur votre forum, 
    etc.

  - Mais que contient une table ? C'est l√† que sont enregistr√©es les donn√©es, sous la forme d'un tableau. Dans 
    ce tableau, les colonnes sont appel√©es des "champs", et les lignes sont appel√©es des "entr√©es".

Une table est donc repr√©sent√©e sous la forme d'un tableau.

Par exemple, le tableau suivant vous montre √† quoi peut ressembler le contenu d'une table appel√©e ¬´ Utilisateurs ¬ª :


Number    Full name            Email                          Age            Password

1         Mathieu Nebra        mathieu.nebra@exemple.com      34             P4ssW0rd

2         Laur√®ne Castor       laurene.castor@exemple.com     28             jm_les_cookies

3         Micka√´l Andrieu      mickael.andrieu@exemple.com    34             s3cr3t

4         Vous                 vous@exemple.com               29             123456

‚Ä¶         ‚Ä¶                    ‚Ä¶                              ‚Ä¶

 


Ce tableau repr√©sente le contenu d'une table (c'est-√†-dire le tiroir de l'armoire).

Chaque ligne est une entr√©e. Ici, il y en a quatre, mais une table peut tr√®s bien contenir 100, 1 000, ou m√™me 100 000 entr√©es.

Tr√®s souvent, on cr√©e un champ "Number", aussi appel√© "ID" (identifiant).

Comme nous le verrons plus tard, il est tr√®s pratique de num√©roter ses entr√©es, m√™me si ce n'est pas obligatoire.

Et pour finir, voici l'indispensable sch√©ma pour que tout √ßa soit clair :

La base de donn√©es contient plusieurs tables (on peut en mettre autant que l'on veut √† l'int√©rieur).

Rappel : chaque table est en fait un tableau o√π les colonnes sont appel√©es champs et o√π les lignes sont appel√©es entr√©es.

Pour vous donner quelques exemples concrets, voici le nom des tables que vous allez devoir cr√©er pour compl√©ter votre site de partage de recettes :

  - users : stocke tous les comptes utilisateur de votre site ;

  - recipes : stocke toutes les recettes de votre site ;

  - comments : stocke tous les commentaires li√©s aux recettes.

Si quelque chose ne vous para√Æt pas clair, si vous avez l'impression de m√©langer un peu "bases", "tables", "champs" ou "entr√©es", relisez de nouveau cette partie. Il faut que vous soyez capable de reproduire le sch√©ma tout seul sur un bout de papier.

Enregistrez les donn√©es

Avant de terminer le chapitre, voici une question que l'on se pose fr√©quemment, quand on lit ce genre de chapitre sur les bases de donn√©es pour la premi√®re fois.

Ils sont bien jolis ces tableaux et ces sch√©mas, ces bases, ces champs‚Ä¶ Mais je vois pas ce que c'est concr√®tement, moi ! O√π est-ce que MySQL enregistre les donn√©es ?

En fait, tout ce que je viens de vous montrer, c'est une fa√ßon de ¬´ visualiser ¬ª la chose. Il faut que vous imaginiez que la base de donn√©es g√®re les informations sous forme de tableaux, parce que c'est la meilleure repr√©sentation qu'on puisse s'en faire.

Mais concr√®tement, quand MySQL enregistre des informations, il les √©crit bien quelque part. Oui, comme tout le monde, il les enregistre dans des fichiers !

Ces fichiers sont quelque part sur votre disque dur, mais il ne faut jamais les ouvrir et encore moins les modifier directement. Il faut toujours parler avec MySQL qui va se charger d'extraire et de modifier les informations dans ces fichiers.

Chaque SGBD a sa propre fa√ßon d'enregistrer les donn√©es, mais aucun d'eux ne peut y √©chapper : pour que les donn√©es restent enregistr√©es, il faut les stocker dans des fichiers sur le disque dur.

Par exemple, avec MySQL sous Windows, si vous utilisez XAMPP, vous devriez trouver les fichiers o√π sont stock√©es les informations dans  C:\xampp\mysql\data  .

C'est le m√™me principe si vous utilisez MAMP, WAMP... : les fichiers de la base de donn√©es sont bien quelque part !

Je vous recommande tr√®s fortement de ne pas y toucher, car ils ne sont pas pr√©vus pour √™tre modifi√©s directement !

Dans la pratique, on n'ira jamais toucher √† ces fichiers directement. On demandera TOUJOURS √† MySQL d'enregistrer, ou d'aller lire des choses. Apr√®s, c'est lui qui se d√©brouille pour classer √ßa comme il veut dans ses fichiers.

Et c'est justement √ßa, le gros avantage de la base de donn√©es : pas de prise de t√™te pour le rangement des informations. Vous demandez √† MySQL de vous sortir tous les commentaires d'une recette de votre site enregistr√©es de f√©vrier √† juillet : il va lire dans ses fichiers, et vous ressort les r√©ponses. Vous vous contentez de "dialoguer" avec MySQL. Lui se charge du sale boulot, c'est-√†-dire de ranger vos donn√©es dans ses fichiers.

En r√©sum√©

- Une base de donn√©es est un outil qui stocke vos donn√©es de mani√®re organis√©e et vous permet de les retrouver 
  facilement par la suite.

- On communique avec MySQL gr√¢ce au langage SQL. Ce langage est commun √† tous les syst√®mes de gestion de base 
  de donn√©es (avec quelques petites diff√©rences n√©anmoins pour certaines fonctionnalit√©s plus avanc√©es).

- PHP fait l'interm√©diaire entre vous et MySQL.

- Une base de donn√©es contient plusieurs tables.

- Chaque table est un tableau o√π les colonnes sont appel√©es ¬´ champs ¬ª et les lignes ¬´ entr√©es ¬ª.

Nous arrivons au c≈ìur du sujet de cette derni√®re partie du cours : la mise en place d'une base de donn√©es avec phpMyAdmin.

##############################################################################################################

Mettez en place une base de donn√©es avec phpMyAdmin

Dans ce chapitre, vous allez cr√©er et mettre en place la base de donn√©es pour votre site de partage de recettes.

Pour communiquer avec MySQL, nous pouvons utiliser diff√©rents logiciels : de l'invite de commandes jusqu'√† des logiciels accessibles par le navigateur. Ici, vous allez utiliser phpMyAdmin, l'un des outils les plus connus permettant de manipuler une base de donn√©es MySQL.

phpMyAdmin est livr√© avec XAMPP ; vous allez donc pouvoir vous en servir tout de suite !

Cr√©ez une table pour les recettes

Pour cr√©er une table qui correspond √† une recette, nous allons devoir associer chacune des propri√©t√©s de nos recettes √† un champ de la table, et lui associer un type de donn√©es.

Ensuite, nous devons d√©finir un champ qui servira d'identifiant unique (un peu comme un num√©ro de S√©curit√© sociale), de sorte √† pouvoir retrouver chaque recette :

Les types de champs MySQL

Alors que PHP ne propose que quelques types de donn√©es que l'on conna√Æt bien maintenant ( int  , string  , bool  ‚Ä¶), MySQL propose une quantit√© tr√®s importante de types de donn√©es.

Mais dans la pratique, vous n'aurez besoin de jongler qu'entre les quatre types de donn√©es suivants :

  1. INT : nombre entier ;

  2. VARCHAR : texte court (entre 1 et 255 caract√®res) ;

  3. TEXT : long texte (on peut y stocker un roman sans probl√®me) ;

  4. DATE : date (jour, mois, ann√©e).

Cela couvrira 99 % de vos besoins, et avec l'exp√©rience vous apprendrez √† optimiser vos bases de donn√©es, et l'int√©r√™t des autres types de donn√©es de MySQL.

Les cl√©s primaires

Toute table doit poss√©der un champ qui joue le r√¥le de cl√© primaire. La cl√© primaire permet d'identifier de mani√®re unique une entr√©e dans la table. En g√©n√©ral, on utilise le champ id comme cl√© primaire, comme on vient de le faire.

Prenez le r√©flexe de cr√©er √† chaque fois ce champ ¬´ id ¬ª en lui donnant l'index PRIMARY  , ce qui aura pour effet d'en faire une cl√© primaire.

Vous en profiterez en g√©n√©ral pour cocher la case AUTO_INCREMENT pour que ce champ g√®re lui-m√™me les nouvelles valeurs automatiquement (1, 2, 3, 4‚Ä¶).

Modifiez une table

Mais‚Ä¶ je ne vais pas devoir passer par phpMyAdmin √† chaque fois que je veux ajouter ou supprimer un √©l√©ment, quand m√™me ?

Non, bien s√ªr que non.

Vous allez apprendre √† le faire en PHP dans les chapitres suivants.

Il nous reste encore √† d√©couvrir deux des nombreuses fonctionnalit√©s offertes par phpMyAdmin, et nous aurons termin√© notre tour d'horizon de cet outil : l'import et l'export de base de donn√©es.

Importez et exportez des donn√©es

Vous allez ici vous int√©resser √† l'onglet "Import" de phpMyAdmin, dont le principal int√©r√™t est de cr√©er une base de donn√©es enti√®re avec tables et donn√©es :

Explorez maintenant l'onglet ¬´ Exporter ¬ª de phpMyAdmin.

C'est ici que vous allez pouvoir r√©cup√©rer votre base de donn√©es sur le disque dur, sous forme de fichier texte .sql  (qui contiendra des tonnes de requ√™tes SQL).

Le fichier que vous allez obtenir gr√¢ce √† ¬´ l'exportation ¬ª de phpMyAdmin, c'est un fichier qui dit √† MySQL comment recr√©er votre base de donn√©es (avec des requ√™tes en langage SQL). Et ce fichier-l√† est tout √† fait lisible.

√Ä quoi sert ce fichier ?

On peut s'en servir pour deux choses :

  1. Transmettre votre base de donn√©es sur Internet : pour le moment, votre base de donn√©es se trouve sur 
     votre disque dur. Mais lorsque vous voudrez h√©berger votre site sur Internet, il faudra utiliser la base 
     de donn√©es en ligne de votre h√©bergeur ! Le fichier .sql que vous allez g√©n√©rer vous permettra de 
     reconstruire la base de donn√©es √† l'identique.

  2. Faire une copie de sauvegarde de la base de donn√©es : on ne sait jamais, si vous faites une b√™tise ou si 
     quelqu'un r√©ussit √† d√©truire toutes les informations sur votre site, vous serez bien content d'avoir une 
     copie de secours sur votre disque dur !

Exercez-vous

Il est temps de cr√©er la base de donn√©es pour notre projet fil rouge.

  - T√©l√©chargez le fichier d'import de la base de donn√©es √† partir du dossier P4C2 du GitHub. 

  - Suivez les √©tapes que nous avons vues dans le cours en utilisant phpMyAdmin pour importer le fichier SQL 
    que vous venez de t√©l√©charger.

En r√©sum√©

- phpMyAdmin est un outil qui nous permet de visualiser rapidement l'√©tat de notre base de donn√©es et de la 
  modifier, sans avoir √† √©crire de requ√™tes SQL.

- On cr√©e g√©n√©ralement un champ nomm√© id  qui sert √† num√©roter les entr√©es d'une table. Ce champ doit avoir un 
  index PRIMARY (on dit qu'on cr√©e une cl√© primaire) et l'option AUTO_INCREMENT qui permet de laisser MySQL 
  g√©rer la num√©rotation.

- MySQL g√®re diff√©rents types de donn√©es pour ses champs, √† la mani√®re de PHP. On trouve des types adapt√©s au 
  stockage de nombres, de textes, de dates, etc.

- phpMyAdmin poss√®de un outil d'importation et d'exportation des tables qui nous permettra notamment d'envoyer 
  notre base de donn√©es sur Internet ou d'en conserver une copie.

Dans le prochain chapitre, nous allons voir comment acc√©der aux donn√©es en PHP avec PDO. C'est parti !

##############################################################################################################

Acc√©dez aux donn√©es en PHP avec PDO

Vous allez maintenant communiquer avec votre base de donn√©es de recettes via PHP.

√Ä la fin de ce chapitre, vous aurez obtenu une nouvelle version de la page d'accueil du site, cette fois cr√©√©e √† l'aide de PHP et de MySQL !

Connectez-vous √† la base de donn√©es en PHP
Pour pouvoir travailler avec la base de donn√©es en PHP, il faut d'abord s'y connecter.

Il va donc falloir que PHP s'authentifie : on dit qu'il √©tablit une connexion avec MySQL.

Une fois que la connexion sera √©tablie, vous pourrez faire toutes les op√©rations que vous voudrez sur votre base de donn√©es !

Pour se connecter √† une base de donn√©es MySQL, vous allez devoir utiliser une extension PHP appel√©e PDO ("PHP Data Objects"). Cette extension est fournie avec PHP (en fran√ßais, "les fonctions PDO sont √† votre disposition"), mais parfois il vous faudra activer l'extension.

V√©rifiez que PDO est bien activ√©

Je vous recommande de passer la ligne display_errors  sur "On" pour que les erreurs s'affichent ; √ßa va grandement nous aider :

display_errors = On

Si vous √™tes sous Linux et que vous utilisez XAMPP, recherchez la ligne qui commence par pdo_mysql.default_socket  et compl√©tez-la comme ceci :

pdo_mysql.default_socket = /opt/lampp/var/mysql/mysql.sock

Enregistrez le fichier puis red√©marrez PHP. Il suffit pour cela de relancer votre logiciel favori (MAMP, XAMPP‚Ä¶).

Connectez PHP √† MySQL avec PDO

Maintenant que nous sommes certains que PDO est activ√©, nous pouvons nous connecter √† MySQL. Nous allons avoir besoin de quatre renseignements :

  - Le nom de l'h√¥te : c'est l'adresse IP de l'ordinateur o√π MySQL est install√©. Le plus souvent, MySQL est 
    install√© sur le m√™me ordinateur que PHP : dans ce cas, mettez la valeur localhost . 

  - La base : c'est le nom de la base de donn√©es √† laquelle vous voulez vous connecter. Dans notre cas, la 
    base s'appelle partage_de_recettes . Vous l'avez cr√©√©e avec phpMyAdmin dans le chapitre pr√©c√©dent.

  - L'identifiant et le mot de passe : ils permettent de vous identifier. Renseignez-vous aupr√®s de votre 
    h√©bergeur pour les conna√Ætre.

Si vous utilisez MAMP, la valeur de l'identifiant et du mot de passe est la m√™me : root.

Voici donc l'instruction PDO pour vous connecter √† votre base partage_de_recettes :

<?php
$mysqlClient = new PDO(
	'mysql:host=localhost;dbname=partage_de_recettes;charset=utf8',
	'root',
	''
);
?>

Je ne comprends rien √† ce code, c'est normal ?

Oui, il faut reconna√Ætre qu'il contient quelques nouveaut√©s.

En effet, PDO est ce qu'on appelle une extension orient√©e objet. C'est une fa√ßon de programmer un peu diff√©rente des fonctions classiques que l'on a appris √† utiliser jusqu'ici.

Pour l'instant, je vous invite √† r√©utiliser les codes que je vous propose en suivant mes exemples. Vous comprendrez les d√©tails de leur mode de fonctionnement un peu plus tard.

La ligne de code qu'on vient de voir cr√©e une connexion √† la base de donn√©es.

En fait, on cr√©e la connexion en indiquant dans l'ordre dans les param√®tres :

  - le nom d'h√¥te : localhost ;

  - la base de donn√©es : partage_de_recettes ;

  - l'identifiant (login) : root ;

  - le mot de passe (Sous XAMPP, il n‚Äôy a pas de mot de passe par d√©faut. Pour cela, nous utiliserons la 
    cha√Æne de caract√®res vide.).

Lorsque votre site sera en ligne, vous aurez s√ªrement un nom d'h√¥te diff√©rent, ainsi qu'un identifiant et un mot de passe, comme ceci :

<?php
$mysqlClient = new PDO('mysql:host=sql.hebergeur.com;dbname=mabase;charset=utf8', 'pierre.durand', 's3cr3t');
?>

Il faudra donc penser √† changer cette ligne pour l'adapter √† votre h√©bergeur en modifiant les informations en cons√©quence, lorsque vous enverrez votre site sur le Web.

Le premier param√®tre (qui commence par mysql  ) s'appelle le DSN : Data Source Name. C'est g√©n√©ralement le seul qui change en fonction du type de base de donn√©es auquel on se connecte.

Testez la pr√©sence d'erreurs

Si vous avez renseign√© les bonnes informations (nom de l'h√¥te, de la base, login et mot de passe), rien ne devrait s'afficher √† l'√©cran.

Toutefois, s'il y a une erreur (vous vous √™tes tromp√© de mot de passe ou de nom de base de donn√©es, par exemple), PHP risque d'afficher toute la ligne qui pose l'erreur, ce qui inclut le mot de passe !

Vous ne voudrez pas que vos visiteurs puissent voir le mot de passe si une erreur survient lorsque votre site est en ligne. Il est pr√©f√©rable de traiter l'erreur.

En cas d'erreur, PDO renvoie ce qu'on appelle une exception, qui permet de ¬´ capturer ¬ª l'erreur.

Voici comment je vous propose de faire :

<?php
try
{
    $mysqlClient = new PDO('mysql:host=localhost;dbname=partage_de_recettes;charset=utf8', 'root', '');
}
catch (Exception $e)
{
    die('Erreur : ' . $e->getMessage());
}
?>

Voil√† encore un code un peu nouveau pour nous : sans trop rentrer dans le d√©tail, il faut savoir que PHP essaie d'ex√©cuter les instructions √† l'int√©rieur du bloc try  :

  - S'il y a une erreur, il rentre dans le bloc catch et fait ce qu'on lui demande (ici, on arr√™te l'ex√©cution 
    de la page en affichant un message d√©crivant l'erreur).

  - Si au contraire tout se passe bien, PHP poursuit l'ex√©cution du code et ne lit pas ce qu'il y a dans le 
    bloc catch  . Votre page PHP ne devrait donc rien afficher pour le moment.

Ouh l√† ! Tout √ßa semble bien compliqu√©, je n'y comprends pas grand-chose ! C'est grave, docteur ?

Non, pas du tout ! En fait, et j'insiste l√†-dessus, PDO nous fait utiliser des fonctionnalit√©s de PHP que l'on n'a pas √©tudi√©es jusqu'√† pr√©sent (programmation orient√©e objet, exceptions‚Ä¶). Contentez-vous pour le moment de r√©utiliser les codes que je vous propose et n'ayez crainte.

Si vous souhaitez en savoir d√®s maintenant un peu plus sur la gestion des exceptions,  consultez le chapitre sur le sujet dans le cours sur la programmation orient√©e objet avec PHP.

Effectuez une premi√®re requ√™te SQL

Maintenant, nous allons apprendre √† lire des informations dans la base de donn√©es, puis nous verrons dans le chapitre suivant comment ajouter et modifier des donn√©es.

L'objectif ici consiste √† r√©cup√©rer la liste des recettes qui √©taient au d√©part dans une variable sous forme de tableau associatif, et qui sont maintenant stock√©es dans votre base de donn√©es.

Arrive alors le grand moment que vous attendiez tous : on va parler √† MySQL. Pour cela, on va faire ce qu'on appelle une requ√™te, en demandant √† MySQL de nous dire ce que contient la table  recipes. 

Construisez votre premi√®re requ√™te SQL

Comme je vous l'ai dit, le SQL est un langage. C'est lui qui nous permet de communiquer avec MySQL.

Voici la premi√®re requ√™te SQL que nous allons utiliser :

SELECT * FROM recipes

Cela peut se traduire par :

¬´ Prendre tout ce qu'il y a dans la table recipes ¬ª.

Analysons chaque terme de cette requ√™te.

  - SELECT : en langage SQL, le premier mot indique quel type d'op√©ration doit effectuer MySQL. Dans ce 
    chapitre, nous ne verrons que SELECT  . Ce mot-cl√© demande √† MySQL d'afficher ce que contient une table.

  - * : apr√®s le SELECT  , on doit indiquer quels champs MySQL doit r√©cup√©rer dans la table. Si on n'est 
    int√©ress√© que par les champs ¬´ nom ¬ª et ¬´ possesseur ¬ª, il faudra taper :
    SELECT nom, possesseur FROM recipes

    Si vous voulez prendre tous les champs, tapez *  . Cette petite √©toile peut se traduire par ¬´ tout ¬ª : 
    ¬´ Prendre tout ce qu'il y a‚Ä¶ ¬ª.

  - FROM : c'est un mot de liaison qui se traduit par ¬´ dans ¬ª. FROM  fait la liaison entre le nom des champs 
    et le nom de la table.

  - recipes : c'est le nom de la table dans laquelle il faut aller piocher.

Effectuons la requ√™te  √† l'aide de l'objet PDO :

<?php
$recipesStatement = $mysqlClient->prepare('SELECT * FROM recipes');
?>

Affichez le r√©sultat d'une requ√™te SQL

Le probl√®me, c'est que $recipesStatement contient quelque chose d'inexploitable directement : un objet PDOStatement. Cet objet va contenir la requ√™te SQL que nous devons ex√©cuter, et par la suite, les informations r√©cup√©r√©es en base de donn√©es.

Pour r√©cup√©rer les donn√©es, demandez √† cet objet d'ex√©cuter la requ√™te SQL et de r√©cup√©rer toutes les donn√©es dans un format "exploitable" pour vous, c'est-√†-dire sous forme d'un tableau PHP.

<?php
$recipesStatement->execute();
$recipes = $recipesStatement->fetchAll();
?>

"Fetch" en anglais signifie ¬´ va chercher ¬ª.

Une fois qu'on a r√©cup√©r√© les donn√©es sous forme d'un tableau PHP, on en revient √† ce que vous connaissez d√©j√† ! Je vous propose de r√©sumer tout ce que vous venez d'apprendre, de la connexion via PDO √† l'affichage du r√©sultat de la requ√™te :

<?php
try {
    // On se connecte √† MySQL
    $mysqlClient = new PDO('mysql:host=localhost;dbname=partage_de_recettes;charset=utf8', 'root', 'root');
} catch (Exception $e) {
    // En cas d'erreur, on affiche un message et on arr√™te tout
    die('Erreur : ' . $e->getMessage());
}
// Si tout va bien, on peut continuer

// On r√©cup√®re tout le contenu de la table recipes
$sqlQuery = 'SELECT * FROM recipes';
$recipesStatement = $mysqlClient->prepare($sqlQuery);
$recipesStatement->execute();
$recipes = $recipesStatement->fetchAll();

// On affiche chaque recette une √† une
foreach ($recipes as $recipe) {
?>
    <p><?php echo $recipe['author']; ?></p>
<?php
}
?>

Affichez seulement le contenu de quelques champs

Avec ce que je vous ai appris, vous devriez √™tre capable d'afficher ce que vous voulez.
Personne ne vous oblige √† afficher tous les champs !

Par exemple, si j'avais juste voulu lister les noms des recettes et le nom de l'auteur, j'aurais utilis√© la requ√™te SQL suivante :

<?php

$sqlQuery = 'SELECT title, author FROM recipes';

Et... c'est tout, vous r√©cup√®rerez seulement les informations dont vous avez besoin, ce qui est plus performant.

Filtrez vos donn√©es

Rappelez-vous votre objectif : on souhaite lister les recettes qui sont activ√©es, c'est-√†-dire celles dont le champ is_enabled vaut TRUE .

√áa para√Æt compliqu√© √† faire, non ?

Pas en SQL !

Vous allez voir qu'en modifiant vos requ√™tes SQL, il est possible de filtrer et trier tr√®s facilement vos donn√©es. Vous allez ici d√©couvrir les mots-cl√©s suivants du langage SQL :

  - WHERE ;

  - ORDER BY ;

  - LIMIT  .

Gr√¢ce au mot-cl√© WHERE , vous allez pouvoir trier vos donn√©es.

Puisque l'on souhaite r√©cup√©rer uniquement les recettes avec le champ is_enabled √†  TRUE , alors la requ√™te au d√©but sera la m√™me qu'avant, mais vous rajouterez  √† la fin WHERE is_enabled = TRUE  .

Cela vous donne la requ√™te :

<?php
$sqlQuery = 'SELECT * FROM recipes WHERE is_enabled = TRUE';

Traduction :

¬´ S√©lectionner tous les champs de la table recipes lorsque le champ is_enabled est √©gal √† vrai ¬ª.

L'utilisation de l'instruction  ORDER BY  a un impact sur la colonne "title". Par exemple, en ex√©cutant la requ√™te  SELECT * FROM recipes ORDER BY title DESC  , les recettes seront correctement tri√©es dans l'ordre d√©croissant en fonction du titre.

La valeur 1 est √©quivalente √† true et la valeur 0 est √©quivalente √† false. Ainsi, les requ√™tes  SELECT * FROM recipes WHERE is_enabled = 1  et  SELECT * FROM recipes WHERE is_enabled = true  renverront les m√™mes donn√©es.

Je n'aborde ici que les bases de l'instruction  SELECT  . Pour en savoir plus, vous pouvez suivre ce cours sur MySQL en compl√©ment, voire en parall√®le de la lecture de ce chapitre.

Plus vous aurez de conditions et plus la requ√™te devient complexe. Avant d'√©crire le code PHP, vous pouvez d√©j√† v√©rifier que la requ√™te SQL est correcte en la testant dans l'onglet "SQL" de phpMyAdmin, comme je viens de vous le montrer.

Il faut utiliser les mots-cl√©s dans l'ordre que j'ai donn√© : WHERE  puis ORDER BY  puis LIMIT , sinon MySQL ne comprendra pas votre requ√™te.

Construisez des requ√™tes en fonction de variables
Les requ√™tes que vous avez ex√©cut√©es jusqu'ici √©taient simples et effectuaient toujours la m√™me op√©ration. Or, les choses deviennent int√©ressantes quand on utilise des variables de PHP dans les requ√™tes.

Identifiez vos variables √† l'aide des marqueurs

Les marqueurs sont des identifiants reconnus par PDO pour √™tre remplac√©s lors de la pr√©paration de la requ√™te par les variables PHP :

En guise d'exemple complet, voici la requ√™te pour retrouver les recettes valides de Mathieu, √©crite dans le respect des meilleures pratiques :

<?php
$sqlQuery = 'SELECT * FROM recipes WHERE author = :author AND is_enabled = :is_enabled';

$recipesStatement = $mysqlClient->prepare($sqlQuery);
$recipesStatement->execute([
'author' => 'mathieu.nebra@exemple.com',
'is_enabled' => true,
]);
$recipes = $recipesStatement->fetchAll();
]);
On ne concat√®ne JAMAIS une requ√™te SQL pour passer des variables, au risque de cr√©er des injections SQL ! Le sujet des injections SQL est un peu trop complexe pour √™tre d√©taill√© ici. Si vous souhaitez en apprendre plus √† ce sujet, je vous invite √† consulter Wikipedia.

Traquez les erreurs

Lorsqu'une requ√™te SQL ¬´ plante ¬ª, bien souvent PHP vous dira qu'il y a eu une erreur √† la ligne du fetchAll :

Fatal error: Call to a member function fetchAll() on a non-object in index.php on line 13
Ce n'est pas la ligne du fetchAll qui est en cause : c'est souvent vous qui avez mal √©crit votre requ√™te SQL quelques lignes plus haut. Pour afficher des d√©tails sur l'erreur, il faut activer les erreurs lors de la connexion √† la base de donn√©es via PDO.

Il faut adapter la cr√©ation de l'objet $mysqlClient pour activer la gestion des erreurs :

<?php
$mysqlClient = new PDO(
    'mysql:host=localhost;dbname=partage_de_recettes;charset=utf8',
    'root',
    '',
    [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION],
);
?>

D√©sormais, toutes vos requ√™tes SQL qui comportent des erreurs les afficheront avec un message beaucoup plus clair.

Supposons par exemple que j'√©crive mal le nom du champ :

SELECT titlee FROM recipes
L'erreur suivante s'affichera alors :

Unknown column 'titlee' in 'field list'
Si on traduit, cela signifie :

¬´ La colonne titlee  est introuvable dans la liste des champs ¬ª.

En effet, le champ s'appelle title .

Lorsque vous avez un probl√®me avec une requ√™te et que vous voulez demander de l'aide, pensez toujours √† activer les erreurs lors de la connexion √† la base de donn√©es comme je viens de vous montrer, cela vous permettra d'avoir un message d'erreur d√©taill√©.

N'oubliez pas que personne ne peut vous aider si vous donnez juste le message par d√©faut Call to a member function fetchAll() on a non-object  !

Exercez-vous

Maintenant, nous allons appliquer les concepts que vous avez appris sur ce chapitre. Vous allez cr√©er un fichier de configuration MySQL, √©tablir une connexion √† la base de donn√©es via PDO, et remplacer l'utilisation de tableaux statiques par des requ√™tes SQL dynamiques pour r√©cup√©rer les utilisateurs et les recettes depuis la base de donn√©es :

√âtape 1 : Cr√©ation du fichier mysql.php dans le dossier config

Commencez par cr√©er un fichier nomm√© mysql.php dans le dossier config. Ce fichier contiendra les informations n√©cessaires √† la connexion √† MySQL via PDO, telles que le nom d'h√¥te, le nom d'utilisateur, le mot de passe et le nom de la base de donn√©es.

√âtape 2 : Cr√©ation du fichier databaseconnect.php

Ensuite, cr√©ez un nouveau fichier nomm√© databaseconnect.php. Ce fichier facilitera la connexion √† la base de donn√©es via PDO en utilisant les variables d√©finies dans mysql.php.

√âtape 3 : Modification du fichier variables.php

Enfin, modifiez le fichier variables.php pour remplacer les tableaux statiques $users et $recipes par l'utilisation de requ√™tes SQL. Cela permettra de r√©cup√©rer dynamiquement les utilisateurs et les recettes depuis la base de donn√©es √† l'aide de PDO.

Vous pouvez retrouver le code modifi√© dans le dossier P4C3 du GitHub.

En r√©sum√©

- Pour dialoguer avec MySQL depuis PHP, on fait appel √† l'extension PDO de PHP.

- Avant de dialoguer avec MySQL, il faut s'y connecter. On a besoin de l'adresse IP de la machine o√π se trouve 
  MySQL, du nom de la base de donn√©es ainsi que d'un identifiant et d'un mot de passe.

- Les requ√™tes SQL commen√ßant par SELECT permettent de r√©cup√©rer des informations dans une base de donn√©es.

- Il faut faire une boucle en PHP pour r√©cup√©rer ligne par ligne les donn√©es renvoy√©es par MySQL.

- Le langage SQL propose de nombreux outils pour pr√©ciser nos requ√™tes, √† l'aide notamment des mots-cl√©s WHERE  
  (filtre), ORDER BY  (tri) et LIMIT  (limitation du nombre de r√©sultats).

- Pour construire une requ√™te en fonction de la valeur d'une variable, on passe par des marqueurs qui 
  permettent d'√©viter les dangereuses failles d'injection SQL.

Vous vous demandez comment ajouter, modifier et supprimer des recettes de notre site de partage ? C'est justement ce que nous allons voir dans le prochain chapitre !

##############################################################################################################

Ajoutez, modifiez et supprimez des recettes !

Vous avez appris dans le chapitre comment ajouter de nouvelles entr√©es en base sur phpMyAdmin, mais si vous voulez que des utilisateurs contribuent √† votre site, il faudra leur proposer un formulaire de cr√©ation et de modification !

Pour cela, vous allez aborder de nouvelles requ√™tes SQL fondamentales et les appliquer avec PHP : INSERT  , UPDATE  et DELETE  .

Pour faciliter la compr√©hension de ce chapitre, vous pouvez t√©l√©charger d√®s √† pr√©sent une version  mise √† jour du projet fil rouge. 

Les ajouts effectu√©s comprennent :

  - l'int√©gration d'un lien dans notre menu permettant d'ajouter une recette (voir header.php).

  - l'ajout d'un lien de modification et d'un lien de suppression pour chaque recette (voir index.php).

  - la mise en place d'un test permettant de v√©rifier si l'utilisateur est connect√© avant d'autoriser l'ajout, 
    la modification et la suppression d'une recette (voir isConnect.php).

Impl√©mentez l'ajout de recettes

Votre premi√®re mission ‚Äì si vous l'acceptez ‚Äì c'est l'ajout d'un formulaire de contribution de recettes.

Pour cela, vous aurez besoin de trois choses :

  1. Ajouter un formulaire PHP de cr√©ation de recettes.

  2. V√©rifier les donn√©es soumises en PHP.

  3. √Ä l'aide de PDO, ex√©cuter l'insertion de la nouvelle recette en base de donn√©es.

Vous connaissez d√©j√† les deux premi√®res √©tapes, donc nous ne les d√©taillerons pas dans ce chapitre, mais vous retrouverez le code complet dans l'archive t√©l√©charg√©e.

 Je vais vous parler des fondamentaux de l'insertion en base de donn√©es dans ce chapitre.

Pour en savoir plus, consultez le chapitre "Ins√©rez des donn√©es dans votre BDD" du cours MySQL.

Ajoutez une recette avec l'instruction INSERT INTO
Pour ajouter une entr√©e, vous aurez besoin de conna√Ætre la requ√™te SQL. En voici une par exemple qui ajoute une recette :

<?php
$sqlQuery = 'INSERT INTO recipes(title, recipe, author, is_enabled) VALUES (:title, :recipe, :author, :is_enabled)';

√âtudions un peu cette requ√™te.

- D'abord, vous devez commencer par les mots-cl√©s INSERT INTO  qui indiquent que vous voulez ins√©rer une 
  entr√©e.

- Vous pr√©cisez ensuite le nom de la table (ici recipes  ), puis listez entre parenth√®ses les noms des champs 
  dans lesquels vous souhaitez placer des informations.

- Enfin ‚Äì et c'est l√† qu'il ne faut pas se tromper ‚Äì vous inscrivez VALUES  suivi des valeurs √† ins√©rer dans 
  le m√™me ordre que les champs que vous avez indiqu√©s.

Utilisez cette requ√™te SQL au sein d'un script PHP  :

<?php
try
{
	$mysqlClient = new PDO('mysql:host=localhost;dbname=my_recipes;charset=utf8', 'root', 'root');
}
catch (Exception $e)
{
        die('Erreur : ' . $e->getMessage());
}

// Ecriture de la requ√™te
$sqlQuery = 'INSERT INTO recipes(title, recipe, author, is_enabled) VALUES (:title, :recipe, :author, :is_enabled)';

// Pr√©paration
$insertRecipe = $mysqlClient->prepare($sqlQuery);

// Ex√©cution ! La recette est maintenant en base de donn√©es
$insertRecipe->execute([
    'title' => 'Cassoulet',
    'recipe' => 'Etape 1 : Des flageolets ! Etape 2 : Euh ...',
    'author' => 'contributeur@exemple.com',
    'is_enabled' => 1, // 1 = true, 0 = false
]);

Vous remarquerez que je n'ai pas pass√© de valeur pour le champ  recipe_id .

C'est normal ! Le champ a la propri√©t√© AUTO_INCREMENT  , MySQL lui attribuera une valeur automatiquement. 

Et si j'ai pass√© une valeur bool√©enne pour le champ  is_enabled  , c'est parce que j'ai fait le choix de stocker cette information sous forme d'entier :

  - 0 pour FAUX ;

  - et 1 pour VRAI.

Si vous voulez passer les valeurs PHP true ou false  , alors il faudra d√©clarer le champ  is_enabled avec le type MySQL BOOL .

G√©n√©ralement, on r√©cup√®rera des variables de $_POST  (issues d'un formulaire) pour ins√©rer une entr√©e dans la base de donn√©es :

√âditez une recette avec l'instruction UPDATE

Vos utilisateurs souhaitent maintenant pouvoir modifier leurs recettes.

Pour cela, vous aurez besoin de deux nouveaux mots-cl√©s :  UPDATE  et  SET  .

En imaginant qu'on fournit un formulaire d'√©dition et que l'on autorise les utilisateurs √† √©diter les champs title et recipe , voici la requ√™te SQL correspondante :

UPDATE recipes SET title = :title, recipe = :recipe WHERE recipe_id = :id

Comment √ßa marche ?

- Tout d'abord, le mot-cl√© UPDATE permet de dire qu'on va modifier une entr√©e.

- Ensuite, le nom de la table ( recipes ).

- Le mot-cl√© SET s√©pare le nom de la table de la liste des champs √† modifier.

- Viennent ensuite les champs qu'il faut modifier, s√©par√©s par des virgules. Ici, on modifie le champ title , 
  puis on fait de m√™me pour le champ recipe . Les autres champs ne seront pas modifi√©s.

- Enfin, le mot-cl√© WHERE  est tout simplement indispensable. Il nous permet de dire √† MySQL quelle entr√©e il 
  doit modifier (sinon, toutes les entr√©es seraient affect√©es !). On se base tr√®s souvent sur le champ 
  recipe_id pour indiquer quelle entr√©e doit √™tre modifi√©e. 

Et si je veux d√©sactiver toutes les recettes d'un utilisateur, il va falloir faire les requ√™tes de mise √† jour une √† une ?

Non ! Il n'est pas question de passer des heures √† modifier chaque entr√©e une √† une pour √ßa ! En r√©fl√©chissant environ 0,5 seconde, vous allez trouver tout seul la requ√™te SQL qui permet de faire ce qu'on souhaite.

C'est bon, vous avez trouv√© ? Allez, je vous donne la r√©ponse dans le mille :

UPDATE recipes SET is_enabled = 0 WHERE author = 'mickael.andrieu@exemple.com'

Traduction :

¬´ Dans la table recipes , modifier toutes les entr√©es dont le champ author  est √©gal √† "mickael.andrieu@exemple.com", et passer ma valeur de is_enabled √† 0 (false). ¬ª

Qu'il y ait 1, 10, 100 ou 1 000 entr√©es, cette requ√™te √† elle seule suffit pour mettre √† jour toute la table ! Si c'est pas beau, le SQL !

Supprimez des donn√©es avec DELETE

Enfin, voil√† une derni√®re requ√™te qui pourra se r√©v√©ler utile : DELETE  .

Rapide et simple √† utiliser, elle est quand m√™me un poil dangereuse : apr√®s suppression, il n'y a aucun moyen de r√©cup√©rer les donn√©es, alors faites bien attention !

Voici comment on supprime par exemple une recette √† partir de son identifiant :

DELETE FROM recipes WHERE recipe_id=:id

Il n'y a rien de plus facile :

  - DELETE FROM : pour dire ¬´ supprimer dans ¬ª ;

  - recipes : le nom de la table ;

  - WHERE : indispensable pour indiquer quelle(s) entr√©e(s) doi(ven)t √™tre supprim√©e(s).

Si vous oubliez le WHERE , toutes les entr√©es seront supprim√©es. Cela √©quivaut √† vider la table.

Je vous laisse ex√©cuter par vous-m√™me cette requ√™te √† l'aide de PHP !

Traitez les erreurs SQL

Comme vous le savez, le langage SQL est un langage √† part enti√®re dont on se sert en PHP. S'il peut y avoir des erreurs en PHP, il peut aussi y avoir des erreurs en SQL.
Il se peut par exemple que votre requ√™te soit mal √©crite, que la table que vous voulez ouvrir n'existe pas, etc. Bref, les erreurs possibles sont l√† encore nombreuses.

Rep√©rez la requ√™te qui selon vous plante, et forcez l'affichage de l'erreur s'il y en a une, comme ceci :

<?php
$deleteRecipeStatement = $mysqlClient->prepare('DELETE FROM recipes WHERE recipe_id = :id');
$deleteRecipeStatement->execute([
    'id' => $id,
]) or die(print_r($mysqlClient->errorInfo()));

Si la requ√™te fonctionne, aucune erreur ne sera affich√©e. Si en revanche la requ√™te plante, PHP arr√™tera de g√©n√©rer la page et vous affichera l'erreur donn√©e par MySQL‚Ä¶

√Ä partir de l√†, il va falloir vous d√©brouiller tout seul, car les erreurs SQL sont assez nombreuses et je ne peux pas toutes les lister.

En g√©n√©ral, MySQL vous dit : ¬´ You have an error in your SQL syntax near 'XXX' ¬ª. √Ä vous de bien relire votre requ√™te SQL ; l'erreur se trouve g√©n√©ralement pr√®s de l'endroit o√π on vous l'indique.

Sur le m√™me mod√®le et pour am√©liorer votre application, pourquoi ne pas cr√©er un formulaire de cr√©ation de compte pour permettre √† vos visiteurs de contribuer √† de nouvelles recettes ?

Il vous suffira d'adapter la logique expliqu√©e pour les recettes et les requ√™tes SQL pour ins√©rer de nouveaux comptes utilisateurs en base de donn√©es.

Exercez-vous

Ajoutez une fonctionnalit√© au projet fil rouge qui permettra aux utilisateurs de visualiser les d√©tails d'une recette :

  1. Sur la page d'index, ajoutez un lien sur le titre de chaque recette, permettant d'acc√©der au d√©tail de cette recette.

  2. Cr√©ez une nouvelle page, par exemple recipes_read.php, pour afficher les d√©tails d'une recette.

  3. Sur cette page, r√©cup√©rez les informations de la recette s√©lectionn√©e √† partir de la base de donn√©es.

Vous pouvez retrouver le code modifi√© dans le dossier P4C4 du GitHub.

En r√©sum√©

- On utilise diff√©rents mots-cl√©s en fonction du type de modification que l'on souhaite effectuer :

       - INSERT INTO : ajout d'une entr√©e ;

       - UPDATE : modification d'une ou plusieurs entr√©es ;

       - DELETE : suppression d'une ou plusieurs entr√©es.

- Comme pour la s√©lection de donn√©es, on utilise les requ√™tes pr√©par√©es pour personnaliser nos requ√™tes en 
  fonction de variables.

- Lorsqu'on utilise UPDATE  ou DELETE , il faut penser √† filtrer avec un WHERE , sinon toute la table sera 
  affect√©e par l'op√©ration !

- PHP indique si une erreur avec MySQL est intervenue.

Il est maintenant temps de voir comment nous pouvons permettre l'ajout de commentaires. Et nous allons le faire gr√¢ce aux jointures SQL !

##############################################################################################################

Ajoutez des commentaires gr√¢ce aux jointures SQL

Jusque-l√†, vous n'avez travaill√© que sur une seule table √† la fois. Dans la pratique, vous aurez certainement plusieurs tables dans votre base, dont la plupart seront interconnect√©es.

Cela vous permettra :

   - de mieux d√©couper vos informations ;

   - d'√©viter des r√©p√©titions ;

  - et de rendre ainsi vos donn√©es plus faciles √† g√©rer.

Par exemple, dans notre table recipes  , on r√©p√®te √† chaque fois l'e-mail du contributeur de la recette alors qu'il est d√©j√† dans la table users .

Et si on ajoute une gestion des commentaires sur la page d'une recette, alors il faudra lier le commentaire √† un utilisateur et √† une recette.

Pour bien comprendre l'int√©r√™t et la notion de jointure, c'est la fonctionnalit√© que vous allez mettre en place dans ce chapitre : suivez le guide !

Mod√©lisez une relation

Si on consid√®re une page qui affiche la recette avec la possibilit√© que les utilisateurs puissent commenter, voire √©valuer la recette, alors un commentaire a les propri√©t√©s suivantes :

- un identifiant unique ;

- une recette ;

- un auteur ;

- une date de publication ;

- une note (disons de 0 √† 5).

Si on se repr√©sente la table "comments", elle ressemblerait √† ceci :

id     recipe          author                        created_at            ranking      comment

1      Cassoulet       mickael.andrieu@exemple.com   03-08-2021 18:00:00      2          Bof üòê

2      Cassoulet       laurene.castor@exemple.com    01-08-2021 12:00:00      4          Super recette üòç

3      Couscous        mathieu.nebra@exemple.com     30-08-2021 12:00:00      0          Pas bon du tout ! ü§¢

4      Couscous        mickael.andrieu@exemple.com      ...                  ...         ...



Comme vous le voyez, l'auteur et le nom de la recette vont appara√Ætre autant de fois qu'il y a de commentaires d'un auteur ou sur une recette en particulier ! Pourtant, vous aviez d√©j√† centralis√© les informations sur les utilisateurs dans la table users  :

user_id      full_name            email                            password             age

1            Micka√´l Andrieu      mickael.andrieu@exemple.com      ...                  34

2            Laur√®ne Castor       laurene.castor@exemple.com       ...                  28

3            Mathieu Nebra        ...                              ...                  ...



√Ä l'aide de MySQL et gr√¢ce au champ user_id, vous √™tes d√©j√† capable de r√©cup√©rer toutes les informations sur un utilisateur sans avoir √† les √©crire dans une autre table.

Pour rappel :

  1.# Toutes les informations sur Laur√®ne !
  2.SELECT * from users WHERE user_id = 2

Maintenant, il faut modifier la structure de la table comments pour faire r√©f√©rence aux donn√©es disponibles dans la table users  .

Pour cela, le mieux est de cr√©er un champ user_id dans la table comments  qui fait r√©f√©rence au champ user_id dans la table  users  :

id    recipe       user_id       created_at             ranking          comment

1     Cassoulet     1            03-08-2021 18:00:00     2                Bof üòê

2     Cassoulet     2            01-08-2021 12:00:00     4                Super recette üòç

3     Couscous      3            30-08-2021 12:00:00     0                Pas bon du tout ! ü§¢

4     Couscous      1            ...                     ...              ...



MySQL sait donc que le user_id  de valeur 1 dans la table comments correspond √† Micka√´l ?

Non, il ne le sait pas. Il ne voit que des nombres et il ne fait pas la relation entre les deux tables. Il va falloir lui expliquer cette relation dans une requ√™te SQL : on va faire ce qu'on appelle une jointure entre les deux tables.

Comprenez le principe de jointure

Nous avons donc maintenant deux tables :

   1. comments 

   2. users  

Les informations sont s√©par√©es dans des tables diff√©rentes, et c'est bien. Cela √©vite de dupliquer des informations sur le disque.

Cependant, lorsqu'on r√©cup√®re la liste des commentaires, si on souhaite obtenir le nom des auteurs, il faut adapter la requ√™te pour r√©cup√©rer aussi les informations issues de la table users  .

Pour cela, on doit faire une jointure.
Il existe plusieurs types de jointures, qui nous permettent de choisir exactement les donn√©es que l'on veut r√©cup√©rer. Je vous propose d'en d√©couvrir deux, les plus importantes :

  1. Les jointures internes : elles ne s√©lectionnent que les donn√©es qui ont une correspondance entre les deux 
     tables.

  2. Les jointures externes : elles s√©lectionnent toutes les donn√©es, m√™me si certaines n'ont pas de 
     correspondance dans l'autre table.

Il est important de bien comprendre la diff√©rence entre une jointure interne et une jointure externe.

Pour cela, imaginons que nous ayons une 4e personne dans la table des utilisateurs, un certain Manuels Vache, qui n'a jamais publi√© de commentaires :

user_id    full_name          email                          password        age

1          Micka√´l Andrieu    mickael.andrieu@exemple.com    ...             34

2          Laur√®ne Castor     laurene.castor@exemple.com     ...             28

3          Mathieu Nebra      ...                            ...             ...

4          Manuels Vache      ...                            ...             58



Manuels Vache est r√©f√©renc√© dans la table users  mais il n'appara√Æt nulle part dans la table comments  car il n'a jamais comment√©.

  1. Si vous r√©cup√©rez les donn√©es des deux tables √† l'aide d'une jointure interne, Manuels n'appara√Ætra pas 
     dans les r√©sultats de la requ√™te. La jointure interne force les donn√©es d'une table √† avoir une 
     correspondance dans l'autre.

  2. Si vous r√©cup√©rez les donn√©es des deux tables √† l'aide d'une jointure externe, vous aurez toutes les 
     donn√©es de la table des utilisateurs, m√™me s'il n'y a pas de correspondance dans l'autre table des 
     commentaires ; donc Manuels, qui pourtant n'a jamais comment√©, appara√Ætra.

La jointure externe est donc plus compl√®te car elle est capable de r√©cup√©rer plus d'informations, tandis que la jointure interne est plus stricte car elle ne r√©cup√®re que les donn√©es qui ont une √©quivalence dans l'autre table.

Voici par exemple les donn√©es que l'on r√©cup√®rerait avec une jointure interne :

full_name                 comment

Micka√´l Andrieu            Bof üòê

Laur√®ne Castor             Super recette üòç

Mathieu Nebra              Pas bon du tout ! ü§¢

‚Ä¶                          ‚Ä¶



En revanche, avec une jointure externe, on aurait :

full_name                 comment

Micka√´l Andrieu           Bof üòê

Laur√®ne Castor            Super recette üòç

Mathieu Nebra             Pas bon du tout ! ü§¢

Manuels Vache             NULL

...                       ...


Manuels appara√Æt d√©sormais. Comme il n'a jamais comment√©, la valeur associ√©e est  NULL  .

Nous allons maintenant voir comment r√©aliser ces deux types de jointures en pratique.

Effectuez des jointures internes

Une jointure interne peut √™tre effectu√©e √† l'aide du mot-cl√© JOIN :

  1.# Liste des noms et commentaires associ√©s
  2.SELECT u.full_name, c.comment
  3.FROM users u
  4.INNER JOIN comments c
  5.ON u.user_id = c.user_id

Cette fois, on r√©cup√®re les donn√©es depuis une table principale (ici, users ) et on fait une jointure interne ( INNER JOIN  ) avec une autre table ( comments  ).

La liaison entre les champs est faite dans la clause ON un peu plus loin.

Si vous voulez :

  - filtrer ( WHERE  ),

  - ordonner ( ORDER BY  )

  - ou limiter les r√©sultats ( LIMIT  ),

‚Ä¶ vous devez le faire √† la fin de la requ√™te, apr√®s le ¬´ ON u.user_id = c.user_id ¬ª.

Par exemple :

  1.# Liste des noms et commentaires associ√©s
  2.# √† la recette Cassoulet
  3.# limit√© √† 10
  4.SELECT u.full_name, c.comment
  5.FROM recipes r
  6.INNER JOIN comments c ON c.recipe_id = r.recipe_id
  7.INNER JOIN users u ON u.user_id = c.user_id
  8.WHERE r.title = 'Cassoulet'
  9.LIMIT 10

Traduction (inspirez un grand coup avant de lire) :

¬´ R√©cup√©rez le commentaire et le nom de l'auteur dans les tables  users  et  comments  , la liaison entre les tables se fait sur les champs  user_id  et  recipe_id  , prenez uniquement les commentaires concernant la recette de Cassoulet et seulement les 10 premiers. ¬ª

Il faut s'accrocher avec des requ√™tes de cette taille-l√† !

Effectuez des jointures externes

Les jointures externes permettent de r√©cup√©rer toutes les donn√©es, m√™me celles qui n'ont pas de correspondance.

On pourra ainsi obtenir Manuels Vache dans la liste, m√™me s'il n'a jamais comment√©.

Cette fois, la seule syntaxe disponible est √† base de JOIN  .

Il y a deux √©critures √† conna√Ætre :

  1. LEFT JOIN 

  2. RIGHT JOIN 

Cela revient pratiquement au m√™me, avec une subtile diff√©rence que nous allons voir.

R√©cup√©rez toute la table de gauche avec LEFT JOIN

Reprenons la jointure √† base de INNER JOIN et rempla√ßons tout simplement INNER par LEFT :

  1.# Liste des noms et commentaires associ√©s
  2.SELECT u.full_name, c.comment
  3.FROM users u
  4.LEFT JOIN comments c
  5.ON u.user_id = c.user_id

users  est appel√©e la ¬´ table de gauche ¬ª et comments  la ¬´ table de droite ¬ª.

Le LEFT JOIN  demande √† r√©cup√©rer tout le contenu de la table de gauche, donc tous les utilisateurs, m√™me si ces derniers n'ont pas d'√©quivalence dans la table comments :


full_name                comment

Micka√´l Andrieu          Bof üòê

Laur√®ne Castor           Super recette üòç

Mathieu Nebra            Pas bon du tout ! ü§¢

Manuels Vache            NULL

...                      ...


Manuels appara√Æt d√©sormais dans les r√©sultats de la requ√™te gr√¢ce √† la jointure externe. Comme il n'a jamais comment√©, la colonne du commentaire est vide.

R√©cup√©rez toute la table de droite avec RIGHT JOIN

Le RIGHT JOIN  demande √† r√©cup√©rer toutes les donn√©es de la table dite ¬´ de droite ¬ª, m√™me si celle-ci n'a pas d'√©quivalent dans l'autre table.

Prenons la requ√™te suivante :

  1.# Liste des noms et commentaires associ√©s
  2.SELECT u.full_name, c.comment
  3.FROM users u
  4.RIGHT JOIN comments c
  5.ON u.user_id = c.user_id

La table de droite est ¬´ comments ¬ª. On r√©cup√®rerait donc tous les commentaires, m√™me ceux qui n'ont pas d'auteur associ√©.

Comment est-ce possible qu'un commentaire n'ait pas d'utilisateur associ√© ?

Il y a deux cas possibles :

  1. Soit le champ user_id  contient une valeur qui n'a pas d'√©quivalent dans la table  users  , par exemple 
     ¬´ 56 ¬ª.

  2. Soit le champ user_id vaut NULL  , c'est-√†-dire que la personne qui a comment√© a souhait√© rester anonyme, 
     par exemple. 

Le projet fil rouge ne permet pas √† un visiteur de publier un commentaire sans s'authentifier √† l'aide d'un e-mail, mais rien ne vous emp√™che de d√©velopper cette fonctionnalit√© : c'est votre projet, apr√®s tout !

On obtiendrait donc les donn√©es expos√©es dans le tableau suivant :


full_name                    comment

Micka√´l Andrieu              Bof üòê

Laur√®ne Castor               Super recette üòç

Mathieu Nebra                Pas bon du tout ! ü§¢

NULL                         Le plat est ressorti cram√© √† mon premier essai üò•

...                          ...



D'accord, mais est-ce qu'il ne faudrait pas faire la m√™me chose avec la table recipes ?

Si, compl√®tement ! √Ä ce moment-l√†, vous ferez non pas une mais deux jointures !
Par exemple, la liste des utilisateurs, commentaires et nom de recettes, comme ceci :

  1.SELECT u.full_name, c.comment, r.title
  2.FROM users u
  3.JOIN comments c
  4.    ON u.user_id = c.user_id
  5.JOIN recipes r
  6.    ON c.recipe_id = r.recipe_id


Vous obtiendriez un r√©sultat √©quivalent √† celui-ci :



full_name           comment                         title

Micka√´l Andrieu     Bof üòê                         Cassoulet

Laur√®ne Castor      Super recette üòç               Cassoulet

Mathieu Nebra       Pas bon du tout ! ü§¢           Couscous

‚Ä¶                   ‚Ä¶                               ‚Ä¶




Exercez-vous


